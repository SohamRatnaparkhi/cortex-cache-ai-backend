version: '3.9'
 services:
 postgres:
     container_name: db
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - POSTGRES_DB=blogx_db
     volumes:
       - 'pg_data_blogx:/var/lib/postgresql/data'
       - './db/init.sql:/docker-entrypoint-initdb.d/init.sql'
     ports:
       - '5432:5432'
     restart: always
     image: 'postgres:15.1-alpine'
   redis:
     container_name: redis
     network_mode: my-network
     ports:
       - '6379:6379'
     restart: always
     image: 'redis:7-alpine'

   haproxy:
     container_name: haproxy
     network_mode: my-network
     ports:
       - '8000:80'
     restart: always
     image: sohamkr/blogx_haproxy:0.0
     # build:
     #   context: ./haproxy/
     #   dockerfile: Dockerfile
   api_auth:
     container_name: auth
     network_mode: my-network
     environment:
       - POSTGRES_DB=blogx_db
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8080
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8080:8080'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_auth:0.0'
     # build:
     #   context: ./authentication/
     #   dockerfile: Dockerfile
   api_blog:
     container_name: blog
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8081
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8081:8081'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_blog:0.0'
     # build:
       # context: ./blog/
       # dockerfile: Dockerfile
   api_feed:
     container_name: feed
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8082
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8082:8082'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_feed:0.0'
     # build:
       # context: ./feed/
       # dockerfile: Dockerfile
   api_user:
     container_name: user
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8083
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8083:8083'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_user:0.1'
     # build:
       # context: ./user/
       # dockerfile: Dockerfile
   swagger_ui:
     container_name: swagger
     network_mode: my-network
     ports:
       - '8084:8084'
     restart: always
     image: 'sohamkr/blogx_swagger:0.0'
     # build:
       # context: ./swagger/
       # dockerfile: Dockerfile
 volumes:
 pg_data_blogx:
 networks:
 my-network:
     driver: bridge
 Location: ./tmp/git_repo/blogx/docker-compose.yaml
 version: '3.9'
 services:
 postgres:
     container_name: db
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - POSTGRES_DB=blogx_db
     volumes:
       - 'pg_data_blogx:/var/lib/postgresql/data'
       - './db/init.sql:/docker-entrypoint-initdb.d/init.sql'
     ports:
       - '5432:5432'
     restart: always
     image: 'postgres:15.1-alpine'
   redis:
     container_name: redis
     network_mode: my-network
     ports:
       - '6379:6379'
     restart: always
     image: 'redis:7-alpine'

   haproxy:
     container_name: haproxy
     network_mode: my-network
     ports:
       - '8000:80'
     restart: always
     image: sohamkr/blogx_haproxy:0.0
     # build:
     #   context: ./haproxy/
     #   dockerfile: Dockerfile
   api_auth:
     container_name: auth
     network_mode: my-network
     environment:
       - POSTGRES_DB=blogx_db
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8080
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8080:8080'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_auth:0.0'
     # build:
     #   context: ./authentication/
     #   dockerfile: Dockerfile
   api_blog:
     container_name: blog
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8081
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8081:8081'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_blog:0.0'
     # build:
       # context: ./blog/
       # dockerfile: Dockerfile
   api_feed:
     container_name: feed
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8082
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8082:8082'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_feed:0.0'
     # build:
       # context: ./feed/
       # dockerfile: Dockerfile
   api_user:
     container_name: user
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8083
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8083:8083'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_user:0.1'
     # build:
       # context: ./user/
       # dockerfile: Dockerfile
   swagger_ui:
     container_name: swagger
     network_mode: my-network
     ports:
       - '8084:8084'
     restart: always
     image: 'sohamkr/blogx_swagger:0.0'
     # build:
       # context: ./swagger/
       # dockerfile: Dockerfile
 volumes:
 pg_data_blogx:
 networks:
 my-network:
     driver: bridge




 **************************************************EOF**************************************************
version: '3.9'
 services:
 postgres:
     container_name: db
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - POSTGRES_DB=blogx_db
     volumes:
       - 'pg_data_blogx:/var/lib/postgresql/data'
       - './db/init.sql:/docker-entrypoint-initdb.d/init.sql'
     ports:
       - '5432:5432'
     restart: always
     image: 'postgres:15.1-alpine'
   redis:
     container_name: redis
     network_mode: my-network
     ports:
       - '6379:6379'
     restart: always
     image: 'redis:7-alpine'

   haproxy:
     container_name: haproxy
     network_mode: my-network
     ports:
       - '8000:80'
     restart: always
     image: sohamkr/blogx_haproxy:0.0
     # build:
     #   context: ./haproxy/
     #   dockerfile: Dockerfile
   api_auth:
     container_name: auth
     network_mode: my-network
     environment:
       - POSTGRES_DB=blogx_db
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8080
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8080:8080'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_auth:0.0'
     # build:
     #   context: ./authentication/
     #   dockerfile: Dockerfile
   api_blog:
     container_name: blog
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8081
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8081:8081'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_blog:0.0'
     # build:
       # context: ./blog/
       # dockerfile: Dockerfile
   api_feed:
     container_name: feed
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8082
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8082:8082'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_feed:0.0'
     # build:
       # context: ./feed/
       # dockerfile: Dockerfile
   api_user:
     container_name: user
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8083
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8083:8083'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_user:0.1'
     # build:
       # context: ./user/
       # dockerfile: Dockerfile
   swagger_ui:
     container_name: swagger
     network_mode: my-network
     ports:
       - '8084:8084'
     restart: always
     image: 'sohamkr/blogx_swagger:0.0'
     # build:
       # context: ./swagger/
       # dockerfile: Dockerfile
 volumes:
 pg_data_blogx:
 networks:
 my-network:
     driver: bridge
 Location: ./tmp/git_repo/blogx/docker-compose.yaml
 version: '3.9'
 services:
 postgres:
     container_name: db
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - POSTGRES_DB=blogx_db
     volumes:
       - 'pg_data_blogx:/var/lib/postgresql/data'
       - './db/init.sql:/docker-entrypoint-initdb.d/init.sql'
     ports:
       - '5432:5432'
     restart: always
     image: 'postgres:15.1-alpine'
   redis:
     container_name: redis
     network_mode: my-network
     ports:
       - '6379:6379'
     restart: always
     image: 'redis:7-alpine'

   haproxy:
     container_name: haproxy
     network_mode: my-network
     ports:
       - '8000:80'
     restart: always
     image: sohamkr/blogx_haproxy:0.0
     # build:
     #   context: ./haproxy/
     #   dockerfile: Dockerfile
   api_auth:
     container_name: auth
     network_mode: my-network
     environment:
       - POSTGRES_DB=blogx_db
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8080
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8080:8080'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_auth:0.0'
     # build:
     #   context: ./authentication/
     #   dockerfile: Dockerfile
   api_blog:
     container_name: blog
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8081
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8081:8081'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_blog:0.0'
     # build:
       # context: ./blog/
       # dockerfile: Dockerfile
   api_feed:
     container_name: feed
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8082
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8082:8082'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_feed:0.0'
     # build:
       # context: ./feed/
       # dockerfile: Dockerfile
   api_user:
     container_name: user
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8083
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8083:8083'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_user:0.1'
     # build:
       # context: ./user/
       # dockerfile: Dockerfile
   swagger_ui:
     container_name: swagger
     network_mode: my-network
     ports:
       - '8084:8084'
     restart: always
     image: 'sohamkr/blogx_swagger:0.0'
     # build:
       # context: ./swagger/
       # dockerfile: Dockerfile
 volumes:
 pg_data_blogx:
 networks:
 my-network:
     driver: bridge




 **************************************************EOF**************************************************
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Authentication server
// @description This is the authentication server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nAuthentication server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe() if err != nil {
		log.Fatal(err)
	}
}
Location: ./tmp/git_repo/blogx/authentication/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Authentication server
// @description This is the authentication server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nAuthentication server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/authentication/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}
Location: ./tmp/git_repo/blogx/authentication/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/authentication/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
) const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/authentication/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package users

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"os"
	"strconv"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Register a user
// @version 1
// @description Register a user with fist name, last name, email, password and bio given in the body
// @Tags authentication
// @accept json
// @param data body database.User true "User details"
// @produce json
// @success 201 {object} utils.DbUserFullSchema
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/register [post] func HandleRegisterUser(w http.ResponseWriter, req *http.Request) {
	type reqBody struct {
		FirstName string         `json:"first_name"`
		LastName  string         `json:"last_name"`
		Email     string         `json:"email"`
		Password  string         `json:"password"`
		Bio       sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	apiConfig := pkg.DbInstance()
	// fmt.Println(&apiConfig)

	saltValueString := os.Getenv("BCRYPT_SALT_VALUE")

	saltValue, bcryptErr := strconv.Atoi(saltValueString)

	if bcryptErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, bcryptErr)
		return
	}
	hashedPassword, err2 := bcrypt.GenerateFromPassword([]byte(bodyDecoded.Password), saltValue)
	if err2 != nil {
		hashedPassword = []byte(bodyDecoded.Password)
	} user, failedToAddToDb := apiConfig.CreateUser(
		req.Context(),
		database.CreateUserParams{
			ID:        uuid.New(),
			FirstName: bodyDecoded.FirstName,
			LastName:  bodyDecoded.LastName,
			Email:     bodyDecoded.Email,
			Password:  string(hashedPassword),
			Bio:       bodyDecoded.Bio,
		},
	)

	if failedToAddToDb != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, failedToAddToDb)
		return
	}

	// create jwt token
	token, expiryTime, jwtTokenError := utils.GetJwt(utils.Credentials{
		Email: bodyDecoded.Email,
		Name:  user.FirstName + user.LastName,
	})

	if jwtTokenError != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, jwtTokenError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   token,
		Expires: expiryTime,
		Path:    "/",
	})

	utils.ResponseJson(w, http.StatusCreated, utils.MapRegisteredUser(user))
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/auth/CreateUser.go
package users import (
	"database/sql"
	"encoding/json"
	"net/http"
	"os"
	"strconv"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Register a user
// @version 1
// @description Register a user with fist name, last name, email, password and bio given in the body
// @Tags authentication
// @accept json
// @param data body database.User true "User details"
// @produce json
// @success 201 {object} utils.DbUserFullSchema
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/register [post] func HandleRegisterUser(w http.ResponseWriter, req *http.Request) {
	type reqBody struct {
		FirstName string         `json:"first_name"`
		LastName  string         `json:"last_name"`
		Email     string         `json:"email"`
		Password  string         `json:"password"`
		Bio       sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	apiConfig := pkg.DbInstance()
	// fmt.Println(&apiConfig)

	saltValueString := os.Getenv("BCRYPT_SALT_VALUE")

	saltValue, bcryptErr := strconv.Atoi(saltValueString)

	if bcryptErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, bcryptErr)
		return
	}
	hashedPassword, err2 := bcrypt.GenerateFromPassword([]byte(bodyDecoded.Password), saltValue)
	if err2 != nil {
		hashedPassword = []byte(bodyDecoded.Password)
	} user, failedToAddToDb := apiConfig.CreateUser(
		req.Context(),
		database.CreateUserParams{
			ID:        uuid.New(),
			FirstName: bodyDecoded.FirstName,
			LastName:  bodyDecoded.LastName,
			Email:     bodyDecoded.Email,
			Password:  string(hashedPassword),
			Bio:       bodyDecoded.Bio,
		},
	)

	if failedToAddToDb != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, failedToAddToDb)
		return
	}

	// create jwt token
	token, expiryTime, jwtTokenError := utils.GetJwt(utils.Credentials{
		Email: bodyDecoded.Email,
		Name:  user.FirstName + user.LastName,
	})

	if jwtTokenError != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, jwtTokenError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   token,
		Expires: expiryTime,
		Path:    "/",
	})

	utils.ResponseJson(w, http.StatusCreated, utils.MapRegisteredUser(user))
}




**************************************************EOF**************************************************package users

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Login a user
// @version 1
// @description Login a user with email and password given in the body
// @Tags authentication
// @accept json
// @produce json
// @success 200 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/login [post] func HandleLoginUser(w http.ResponseWriter, req *http.Request) {
	type ReqBody struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	decoder := json.NewDecoder(req.Body)
	body := ReqBody{}

	err := decoder.Decode(&body)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
	}

	apiConfig := pkg.DbClient

	user, err := apiConfig.GetUserByEmail(req.Context(), body.Email)

	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	authCheck := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(body.Password))

	if authCheck != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, authCheck)
		return
	}

	jwtToken, expiryTime, tokenErr := utils.GetJwt(utils.Credentials{
		Email: user.Email,
		Name:  user.FirstName + user.LastName,
	})

	if tokenErr != nil {
		utils.ErrorResponse(w, http.StatusForbidden, tokenErr)
		return
	} http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   jwtToken,
		Expires: expiryTime,
		Path:    "/",
	})

	// go utils.SendMail(user.Email, fmt.Sprintf("Some on logged in to your account at %v", time.Now()), "Login Verification")

	utils.ResponseJson(w, http.StatusOK, utils.MapLoginUser(user, jwtToken))
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/auth/LoginUser.go
package users

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Login a user
// @version 1
// @description Login a user with email and password given in the body
// @Tags authentication
// @accept json
// @produce json
// @success 200 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/login [post] func HandleLoginUser(w http.ResponseWriter, req *http.Request) {
	type ReqBody struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	decoder := json.NewDecoder(req.Body)
	body := ReqBody{}

	err := decoder.Decode(&body)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
	}

	apiConfig := pkg.DbClient

	user, err := apiConfig.GetUserByEmail(req.Context(), body.Email)

	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	authCheck := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(body.Password))

	if authCheck != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, authCheck)
		return
	}

	jwtToken, expiryTime, tokenErr := utils.GetJwt(utils.Credentials{
		Email: user.Email,
		Name:  user.FirstName + user.LastName,
	})

	if tokenErr != nil {
		utils.ErrorResponse(w, http.StatusForbidden, tokenErr)
		return
	} http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   jwtToken,
		Expires: expiryTime,
		Path:    "/",
	})

	// go utils.SendMail(user.Email, fmt.Sprintf("Some on logged in to your account at %v", time.Now()), "Login Verification")

	utils.ResponseJson(w, http.StatusOK, utils.MapLoginUser(user, jwtToken))
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Logout a user
// @version 1
// @description Logout a user
// @Tags authentication
// @accept json
// @produce json
// @success 202 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/logout [post] func HandleUserLogout(w http.ResponseWriter, _ *http.Request, user database.User) {
	//clear cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})
	utils.ResponseJson(w, http.StatusAccepted, utils.MapLoginUser(user, ""))
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/auth/LogoutUser.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Logout a user
// @version 1
// @description Logout a user
// @Tags authentication
// @accept json
// @produce json
// @success 202 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/logout [post] func HandleUserLogout(w http.ResponseWriter, _ *http.Request, user database.User) {
	//clear cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})
	utils.ResponseJson(w, http.StatusAccepted, utils.MapLoginUser(user, ""))
}




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/authentication/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	authRouter := SetAuthRouter()
	apiRouter.Mount("/auth", authRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/authentication/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	authRouter := SetAuthRouter()
	apiRouter.Mount("/auth", authRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	auth "github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/auth"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/middleware"
	"github.com/go-chi/chi"
)

func SetAuthRouter() chi.Router {
	var authRouter = chi.NewRouter()
	authRouter.Get("/", server.HealthCheck)
	authRouter.Post("/register", auth.HandleRegisterUser)
	authRouter.Post("/login", auth.HandleLoginUser)
	authRouter.Post("/logout", middleware.Auth(middleware.AuthHandler(auth.HandleUserLogout)))
	return authRouter
}
Location: ./tmp/git_repo/blogx/authentication/pkg/routers/Auth.go
package routers

import (
	auth "github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/auth"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/middleware"
	"github.com/go-chi/chi"
) func SetAuthRouter() chi.Router {
	var authRouter = chi.NewRouter()
	authRouter.Get("/", server.HealthCheck)
	authRouter.Post("/register", auth.HandleRegisterUser)
	authRouter.Post("/login", auth.HandleLoginUser)
	authRouter.Post("/logout", middleware.Auth(middleware.AuthHandler(auth.HandleUserLogout)))
	return authRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/authentication/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/authentication/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Token     string         `json:"token"`
} func MapLoginUser(dbUser database.User, token string) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Token:     token,
	}
}
Location: ./tmp/git_repo/blogx/authentication/pkg/utils/UserMap.go
package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Token     string         `json:"token"`
}

func MapLoginUser(dbUser database.User, token string) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Token:     token,
	}
}




**************************************************EOF**************************************************package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Blog server
// @description This is the blog server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nBlog server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
}
Location: ./tmp/git_repo/blogx/blog/main.go
package main import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Blog server
// @description This is the blog server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nBlog server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/blog/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/blog/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/blog/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/blog/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
) const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "redis:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}
Location: ./tmp/git_repo/blogx/blog/db/redis/client.go
package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "redis:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}




**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/blog/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package posts

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Create a post
// @version 1
// @description Create a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.CreatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/addBlog [post] func CreatePostHandler(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Title string
		Body  string
		Tags  []string
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.CreatePost(req.Context(), database.CreatePostParams{
		ID:     uuid.New(),
		Title:  bodyDecoded.Title,
		Body:   bodyDecoded.Body,
		UserID: user.ID,
		Tags:   bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	} allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	allBlogsJson, err := json.Marshal(&allBlogs)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	postJson, err := json.Marshal(&post)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	// append post to allBlogs
	allBlogsJson = append(allBlogsJson, postJson...)
	redisClient.Set(req.Context(), "allBlogs", string(allBlogsJson), 180*time.Second)
	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/AddPost.go
package posts

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
) // @title Create a post
// @version 1
// @description Create a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.CreatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/addBlog [post] func CreatePostHandler(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Title string
		Body  string
		Tags  []string
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.CreatePost(req.Context(), database.CreatePostParams{
		ID:     uuid.New(),
		Title:  bodyDecoded.Title,
		Body:   bodyDecoded.Body,
		UserID: user.ID,
		Tags:   bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	} allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	allBlogsJson, err := json.Marshal(&allBlogs)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	postJson, err := json.Marshal(&post)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	// append post to allBlogs
	allBlogsJson = append(allBlogsJson, postJson...)
	redisClient.Set(req.Context(), "allBlogs", string(allBlogsJson), 180*time.Second)
	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}




**************************************************EOF**************************************************package posts

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Delete a post
// @version 1
// @description Delete a post with post id given in the body
// @Tags posts
// @accept json
// @produce json
// @success 204 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/deleteBlog [delete] func DeletePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	dbErr2 := apiConfig.DeletePost(req.Context(), bodyDecoded.PostId)

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}

/*
testPostBody={
	"id": "some post uuid"
}
*/
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/DeletePost.go
package posts

import (
	"encoding/json"
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Delete a post
// @version 1
// @description Delete a post with post id given in the body
// @Tags posts
// @accept json
// @produce json
// @success 204 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/deleteBlog [delete] func DeletePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	dbErr2 := apiConfig.DeletePost(req.Context(), bodyDecoded.PostId)

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}

/*
testPostBody={
	"id": "some post uuid"
}
*/




**************************************************EOF**************************************************package posts

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Like a post
// @version 1
// @description Like a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/like [get] func HandlePostLike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.LikePost(req.Context(), database.LikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.IncreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
} // @title dislike a post
// @version 1
// @description dislike a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/dislike [get] func HandlePostDislike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.DisLikePost(req.Context(), database.DisLikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.DecreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/LikeDislike.go
package posts

import (
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Like a post
// @version 1
// @description Like a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/like [get] func HandlePostLike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.LikePost(req.Context(), database.LikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.IncreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
} // @title dislike a post
// @version 1
// @description dislike a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/dislike [get] func HandlePostDislike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.DisLikePost(req.Context(), database.DisLikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.DecreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
}




**************************************************EOF**************************************************package posts

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Update a post
// @version 1
// @description Update a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.UpdatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/updateBlog [patch] func UpdatePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
		Title  string    `json:"title"`
		Body   string    `json:"body"`
		Tags   []string  `json:"tags"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.UpdatePost(req.Context(), database.UpdatePostParams{
		ID:    bodyDecoded.PostId,
		Title: bodyDecoded.Title,
		Body:  bodyDecoded.Body,
		Tags:  bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/UpdatePost.go
package posts

import (
	"encoding/json"
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Update a post
// @version 1
// @description Update a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.UpdatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/updateBlog [patch] func UpdatePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
		Title  string    `json:"title"`
		Body   string    `json:"body"`
		Tags   []string  `json:"tags"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.UpdatePost(req.Context(), database.UpdatePostParams{
		ID:    bodyDecoded.PostId,
		Title: bodyDecoded.Title,
		Body:  bodyDecoded.Body,
		Tags:  bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/blog/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetBlogRouter()
	apiRouter.Mount("/blogs", blogRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/blog/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetBlogRouter()
	apiRouter.Mount("/blogs", blogRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	posts "github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/post"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/middleware"
	"github.com/go-chi/chi"
) func SetBlogRouter() chi.Router {
	var blogRouter = chi.NewRouter()
	blogRouter.Get("/", server.HealthCheck)
	blogRouter.Post("/addBlog", middleware.Auth(middleware.AuthHandler(posts.CreatePostHandler)))
	blogRouter.Patch("/updateBlog", middleware.Auth(middleware.AuthHandler(posts.UpdatePostHandler)))
	blogRouter.Delete("/deleteBlog", middleware.Auth(middleware.AuthHandler(posts.DeletePostHandler)))
	blogRouter.Get("/like", middleware.Auth(middleware.AuthHandler(posts.HandlePostLike)))
	blogRouter.Get("/dislike", middleware.Auth(middleware.AuthHandler(posts.HandlePostDislike)))
	return blogRouter
}
Location: ./tmp/git_repo/blogx/blog/pkg/routers/Blog.go
package routers

import (
	posts "github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/post"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/middleware"
	"github.com/go-chi/chi"
) func SetBlogRouter() chi.Router {
	var blogRouter = chi.NewRouter()
	blogRouter.Get("/", server.HealthCheck)
	blogRouter.Post("/addBlog", middleware.Auth(middleware.AuthHandler(posts.CreatePostHandler)))
	blogRouter.Patch("/updateBlog", middleware.Auth(middleware.AuthHandler(posts.UpdatePostHandler)))
	blogRouter.Delete("/deleteBlog", middleware.Auth(middleware.AuthHandler(posts.DeletePostHandler)))
	blogRouter.Get("/like", middleware.Auth(middleware.AuthHandler(posts.HandlePostLike)))
	blogRouter.Get("/dislike", middleware.Auth(middleware.AuthHandler(posts.HandlePostDislike)))
	return blogRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/blog/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID       uuid.UUID `json:"id"`
	Title    string    `json:"title"`
	Body     string    `json:"body"`
	AuthorID uuid.UUID `json:"author_id"`
	Tags     []string  `json:"tags"`
	Views    int32     `json:"views"`
	Likes    int32     `json:"likes"`
} func MapPost(post database.Post) PostMap {
	return PostMap{
		ID:       post.ID,
		Title:    post.Title,
		Body:     post.Body,
		AuthorID: post.UserID,
		Tags:     post.Tags,
		Views:    post.Views,
		Likes:    post.Likes,
	}
}
Location: ./tmp/git_repo/blogx/blog/pkg/utils/MapPostResponse.go
package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID       uuid.UUID `json:"id"`
	Title    string    `json:"title"`
	Body     string    `json:"body"`
	AuthorID uuid.UUID `json:"author_id"`
	Tags     []string  `json:"tags"`
	Views    int32     `json:"views"`
	Likes    int32     `json:"likes"`
} func MapPost(post database.Post) PostMap {
	return PostMap{
		ID:       post.ID,
		Title:    post.Title,
		Body:     post.Body,
		AuthorID: post.UserID,
		Tags:     post.Tags,
		Views:    post.Views,
		Likes:    post.Likes,
	}
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/blog/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************package db

import (
	"fmt"
)

func main() {
	fmt.Println("Database connection")
}
Location: ./tmp/git_repo/blogx/db/main.go
package db

import (
	"fmt"
)

func main() {
	fmt.Println("Database connection")
}




**************************************************EOF**************************************************version: "2"
 sql:
   - schema: "sql/schema"
     queries: "sql/queries"
     engine: "postgresql"
     gen:
       go:
         out: "database"Location: ./tmp/git_repo/blogx/db/sqlc.yaml
 version: "2"
 sql:
   - schema: "sql/schema"
     queries: "sql/queries"
     engine: "postgresql"
     gen:
       go:
         out: "database"



 **************************************************EOF**************************************************
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/feed.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/follower.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nFeed server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
}
Location: ./tmp/git_repo/blogx/feed/main.go
package main import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nFeed server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/feed/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/feed.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/follower.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/feed/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
) const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}
Location: ./tmp/git_repo/blogx/feed/db/redis/client.go
package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}




**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/feed/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package feed

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
) func AllPostNoPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	if allBlogs != "" {
		//convert string to post
		var posts []database.Post
		json.Unmarshal([]byte(allBlogs), &posts)
		utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
		return
	}
	apiConfig := pkg.DbClient
	allPosts, err := apiConfig.GetAllPosts(req.Context())
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
} func AllPostWithPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	offset_string := req.URL.Query().Get("page_no")
	offset, typeCastError := strconv.Atoi(offset_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	LIMIT := 5
	allPosts, err := apiConfig.GetAllPostsPageWise(req.Context(), database.GetAllPostsPageWiseParams{
		Limit:  int32(LIMIT),
		Offset: int32(offset-1) * 5,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/feed/GetAll.go
package feed

import (
	"encoding/json"
	"net/http"
	"strconv" "github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
) func AllPostNoPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	if allBlogs != "" {
		//convert string to post
		var posts []database.Post
		json.Unmarshal([]byte(allBlogs), &posts)
		utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
		return
	}
	apiConfig := pkg.DbClient
	allPosts, err := apiConfig.GetAllPosts(req.Context())
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
} func AllPostWithPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	offset_string := req.URL.Query().Get("page_no")
	offset, typeCastError := strconv.Atoi(offset_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	LIMIT := 5
	allPosts, err := apiConfig.GetAllPostsPageWise(req.Context(), database.GetAllPostsPageWiseParams{
		Limit:  int32(LIMIT),
		Offset: int32(offset-1) * 5,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
}




**************************************************EOF**************************************************package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/google/uuid"
)

func GetPostWithPostId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	_, err := apiConfig.GetPostByPostId(req.Context(), post_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.UpdatePostViews(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err2)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapSinglePost(post))
} func GetMyPosts(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
} func GePostsByUserId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	user_id_string := req.URL.Query().Get("user_id")
	user_uuid, typeCastError := uuid.Parse(user_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/feed/GetPostsIdBased.go
package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/google/uuid"
) func GetPostWithPostId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	_, err := apiConfig.GetPostByPostId(req.Context(), post_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.UpdatePostViews(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err2)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapSinglePost(post))
} func GetMyPosts(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}

func GePostsByUserId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	user_id_string := req.URL.Query().Get("user_id")
	user_uuid, typeCastError := uuid.Parse(user_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}




**************************************************EOF**************************************************package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
)

func PostsOfUsersIFollow(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsOfFollowers(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
} func PostsILiked(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetAllLikedPosts(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/feed/SpecificPosts.go
package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
)

func PostsOfUsersIFollow(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsOfFollowers(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
} func PostsILiked(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetAllLikedPosts(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/feed/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetFeedRouter()
	apiRouter.Mount("/feed", blogRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/feed/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetFeedRouter()
	apiRouter.Mount("/feed", blogRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/feed"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/middleware"
	"github.com/go-chi/chi"
) func SetFeedRouter() chi.Router {
	var feedRouter = chi.NewRouter()
	feedRouter.Get("/", server.HealthCheck)
	feedRouter.Get("/allPosts", middleware.Auth(middleware.AuthHandler(feed.AllPostNoPage)))
	feedRouter.Get("/allPostsPageWise", middleware.Auth(middleware.AuthHandler(feed.AllPostWithPage)))
	feedRouter.Get("/postWithId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/myPosts", middleware.Auth(middleware.AuthHandler(feed.GetMyPosts)))
	feedRouter.Get("/postWithUserId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/followingUsersPosts", middleware.Auth(middleware.AuthHandler(feed.PostsOfUsersIFollow)))
	feedRouter.Get("/myLikedPosts", middleware.Auth(middleware.AuthHandler(feed.PostsILiked)))

	return feedRouter
}
Location: ./tmp/git_repo/blogx/feed/pkg/routers/Feed.go
package routers import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/feed"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/middleware"
	"github.com/go-chi/chi"
) func SetFeedRouter() chi.Router {
	var feedRouter = chi.NewRouter()
	feedRouter.Get("/", server.HealthCheck)
	feedRouter.Get("/allPosts", middleware.Auth(middleware.AuthHandler(feed.AllPostNoPage)))
	feedRouter.Get("/allPostsPageWise", middleware.Auth(middleware.AuthHandler(feed.AllPostWithPage)))
	feedRouter.Get("/postWithId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/myPosts", middleware.Auth(middleware.AuthHandler(feed.GetMyPosts)))
	feedRouter.Get("/postWithUserId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/followingUsersPosts", middleware.Auth(middleware.AuthHandler(feed.PostsOfUsersIFollow)))
	feedRouter.Get("/myLikedPosts", middleware.Auth(middleware.AuthHandler(feed.PostsILiked)))

	return feedRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/feed/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID        uuid.UUID `json:"id"`
	Title     string    `json:"title"`
	Body      string    `json:"body"`
	AuthorID  uuid.UUID `json:"author_id"`
	Tags      []string  `json:"tags"`
	Views     int32     `json:"views"`
	Likes     int32     `json:"likes"`
	CreatedAt string    `json:"created_at"`
}

func MapSinglePost(post database.Post) PostMap {
	return PostMap{
		ID:        post.ID,
		Title:     post.Title,
		Body:      post.Body,
		AuthorID:  post.UserID,
		Tags:      post.Tags,
		Views:     post.Views,
		Likes:     post.Likes,
		CreatedAt: post.CreatedAt.String(),
	}
} func MapAllPosts(posts []database.Post) []PostMap {
	var postMaps []PostMap
	for _, post := range posts {
		postMaps = append(postMaps, MapSinglePost(post))
	}
	return postMaps
}
Location: ./tmp/git_repo/blogx/feed/pkg/utils/PostMapping.go
package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID        uuid.UUID `json:"id"`
	Title     string    `json:"title"`
	Body      string    `json:"body"`
	AuthorID  uuid.UUID `json:"author_id"`
	Tags      []string  `json:"tags"`
	Views     int32     `json:"views"`
	Likes     int32     `json:"likes"`
	CreatedAt string    `json:"created_at"`
}

func MapSinglePost(post database.Post) PostMap {
	return PostMap{
		ID:        post.ID,
		Title:     post.Title,
		Body:      post.Body,
		AuthorID:  post.UserID,
		Tags:      post.Tags,
		Views:     post.Views,
		Likes:     post.Likes,
		CreatedAt: post.CreatedAt.String(),
	}
} func MapAllPosts(posts []database.Post) []PostMap {
	var postMaps []PostMap
	for _, post := range posts {
		postMaps = append(postMaps, MapSinglePost(post))
	}
	return postMaps
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/feed/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig
Location: ./tmp/git_repo/blogx/frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig




**************************************************EOF**************************************************module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
Location: ./tmp/git_repo/blogx/frontend/postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}




**************************************************EOF**************************************************import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}
export default config
Location: ./tmp/git_repo/blogx/frontend/tailwind.config.ts
import type { Config } from 'tailwindcss' const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}
export default config




**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios";

export const login = async (input: LoginData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const {auth} = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.login
    return await axios.post(endpoint, input)
}

export const register = async (input: RegisterData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { auth } = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.register
    return await axios.post(endpoint, input)
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/auth/handler.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios"; export const login = async (input: LoginData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const {auth} = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.login
    return await axios.post(endpoint, input)
}

export const register = async (input: RegisterData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { auth } = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.register
    return await axios.post(endpoint, input)
}



**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { login, register } from "../handler";
import { cookies } from 'next/headers' const request = async (request: NextRequest) => {
    const authType = request.url.split('/').reverse()[0];
    const body = await request.json();
    if (authType == 'login') {
        try {
            const {data, status, statusText} = await login(body)
            const cookieStore = cookies()
            cookieStore.set('auth_token', data.token, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (authType == 'register') {
        try { const { data, status, statusText } = await register(body)
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/auth/[...authType]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { login, register } from "../handler";
import { cookies } from 'next/headers' const request = async (request: NextRequest) => {
    const authType = request.url.split('/').reverse()[0];
    const body = await request.json();
    if (authType == 'login') {
        try {
            const {data, status, statusText} = await login(body)
            const cookieStore = cookies()
            cookieStore.set('auth_token', data.token, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (authType == 'register') {
        try { const { data, status, statusText } = await register(body)
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}



**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios"

export const addBlog = async (blog: AddBlog, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { blogs } = ROUTES;
    const endpoint = serverUrl + blogs.url + blogs.routes.addBlog;
    // const token = localStorage.getItem('token');
    if (!token || token == "" || token == "null") {
        console.log("out")
        throw new Error("No token");
    }

    return await axios.post(endpoint, blog, {
        headers: {
            'auth_token': token
        }
    })
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/mutate/handlers.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios" export const addBlog = async (blog: AddBlog, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { blogs } = ROUTES;
    const endpoint = serverUrl + blogs.url + blogs.routes.addBlog;
    // const token = localStorage.getItem('token');
    if (!token || token == "" || token == "null") {
        console.log("out")
        throw new Error("No token");
    }

    return await axios.post(endpoint, blog, {
        headers: {
            'auth_token': token
        }
    })
}



**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { addBlog } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const type = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    console.log("token = " + token)
    const body = await request.json();
    if (type == 'addBlog') {
        try {
            const {data, status, statusText} = await addBlog(body, token);
            const cookieStore = cookies()
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({ error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/mutate/[...type]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { addBlog } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const type = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    console.log("token = " + token)
    const body = await request.json();
    if (type == 'addBlog') {
        try {
            const {data, status, statusText} = await addBlog(body, token);
            const cookieStore = cookies()
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({ error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}



**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios"

export const allBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.allPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    // console.log("endpoint" + endpoint)
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getBlog = async (token: string, id: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    } const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.postWithId + id;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getMyBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.myPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/query/handlers.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios" export const allBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.allPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    // console.log("endpoint" + endpoint)
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getBlog = async (token: string, id: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    } const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.postWithId + id;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getMyBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.myPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}



**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { allBlogs, getBlog, getMyBlogs } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const possibleTypes = ['allBlogs', 'postWithId', 'myPosts'];
    const currentType = request.url.split('/').reverse();
    const type = possibleTypes.includes(currentType[0]) ? currentType[0] : possibleTypes.includes(currentType[1]) ? currentType[1] : "";
    // console.log(currentType)
    // console.log("url = " + request.url + "type = " + type)
    const token = request.headers.get('Authorization') || '';
    if (type == 'allBlogs') {
        try {
            const {data, status, statusText} = await allBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) { console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'postWithId') {
        try {
            let id = request.url.split('/').reverse()[0];
            const cookieStore = cookies()
            if (id == "undefined" || id == "" || id == undefined) {
                console.log("in")
                id = cookieStore.get('last_post')?.value || "";
            }
            console.log("id=" + id)
            const {data, status, statusText} = await getBlog(token, id);
            console.log(data.id)
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                }) } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'myPosts') {
        try {
            const {data, status, statusText} = await getMyBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404 })
        }
    }
    else {
        return NextResponse.json({
            error: "Invalid request",
            status: 404
        })
    }
} export {
    request as GET
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/query/[...type]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { allBlogs, getBlog, getMyBlogs } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const possibleTypes = ['allBlogs', 'postWithId', 'myPosts'];
    const currentType = request.url.split('/').reverse();
    const type = possibleTypes.includes(currentType[0]) ? currentType[0] : possibleTypes.includes(currentType[1]) ? currentType[1] : "";
    // console.log(currentType)
    // console.log("url = " + request.url + "type = " + type)
    const token = request.headers.get('Authorization') || '';
    if (type == 'allBlogs') {
        try {
            const {data, status, statusText} = await allBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) { console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'postWithId') {
        try {
            let id = request.url.split('/').reverse()[0];
            const cookieStore = cookies()
            if (id == "undefined" || id == "" || id == undefined) {
                console.log("in")
                id = cookieStore.get('last_post')?.value || "";
            }
            console.log("id=" + id)
            const {data, status, statusText} = await getBlog(token, id);
            console.log(data.id)
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                }) } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'myPosts') {
        try {
            const {data, status, statusText} = await getMyBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404 })
        }
    }
    else {
        return NextResponse.json({
            error: "Invalid request",
            status: 404
        })
    }
} export {
    request as GET
}



**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios";

export const getUserById = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getById;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
} export const getUserByEmail = async (id: string, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getByEmail;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}
Location: ./tmp/git_repo/blogx/frontend/src/app/api/user/[...get]/handler.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios"; export const getUserById = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getById;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
} export const getUserByEmail = async (id: string, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getByEmail;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}




**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { getUserByEmail, getUserById } from "./handler"; const request = async (request: NextRequest) => {
    const reqType = request.url.split('/').reverse()[1];
    const identifier = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    if (reqType === 'user') {
        try {
            const { data, status, statusText } = await getUserById(token);
            if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (reqType == 'email') {
        try {
            const { data, status, statusText } = await getUserByEmail(identifier, token); if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as GET
}
Location: ./tmp/git_repo/blogx/frontend/src/app/api/user/[...get]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getUserByEmail, getUserById } from "./handler"; const request = async (request: NextRequest) => {
    const reqType = request.url.split('/').reverse()[1];
    const identifier = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    if (reqType === 'user') {
        try {
            const { data, status, statusText } = await getUserById(token);
            if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (reqType == 'email') {
        try {
            const { data, status, statusText } = await getUserByEmail(identifier, token); if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as GET
}




**************************************************EOF**************************************************import { create } from "zustand"; interface PostStore {
    postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string;
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => void;
    postTitle: string;
    setPostTitle: (postTitle: string) => void;
    postDescription: string;
    setPostDescription: (postDescription: string) => void;
    postTags: string[];
    setPostTags: (postTags: string[]) => void;
    postMdx: string;
    setPostMdx: (postMdx: string) => void;
} export const usePostStore = create<PostStore>((set) => ({
    postHtml: "",
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => set({ postHtml }),
    postTitle: "",
    setPostTitle: (postTitle: string) => set({ postTitle }),
    postDescription: "",
    setPostDescription: (postDescription: string) => set({ postDescription }),
    postTags: [],
    setPostTags: (postTags: string[]) => set({ postTags }),
    postMdx: "",
    setPostMdx: (postMdx: string) => set({ postMdx }),
}));Location: ./tmp/git_repo/blogx/frontend/src/app/store/post.store.ts
import { create } from "zustand"; interface PostStore {
    postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string;
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => void;
    postTitle: string;
    setPostTitle: (postTitle: string) => void;
    postDescription: string;
    setPostDescription: (postDescription: string) => void;
    postTags: string[];
    setPostTags: (postTags: string[]) => void;
    postMdx: string;
    setPostMdx: (postMdx: string) => void;
} export const usePostStore = create<PostStore>((set) => ({
    postHtml: "",
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => set({ postHtml }),
    postTitle: "",
    setPostTitle: (postTitle: string) => set({ postTitle }),
    postDescription: "",
    setPostDescription: (postDescription: string) => set({ postDescription }),
    postTags: [],
    setPostTags: (postTags: string[]) => set({ postTags }),
    postMdx: "",
    setPostMdx: (postMdx: string) => set({ postMdx }),
}));



**************************************************EOF**************************************************const middleLayer = "/v1/api"

export const AUTH_SERVER = middleLayer + '/auth'
export const BLOGS_SERVER = middleLayer + '/blogs'
export const FEED_SERVER = middleLayer + '/feed'
export const USER_SERVER = middleLayer + '/user'

export const AUTH_ROUTES = {
    "login": "/login", 
    "register": "/register", 
    "logout": "/logout", 
}

export const BLOGS_ROUTES = {
    "addBlog": "/addBlog",
    "updateBlog": "/updateBlog",
    "deleteBlog": "/deleteBlog",
    "likeBlog": "/likeBlog?post_id=",
    "dislikeBlog": "/dislikeBlog?post_id=",
}

export const FEED_ROUTES = {
    "allPosts": "/allPosts",
    "allPostsPageWise": "/allPostsPageWise?page_no=",
    "postWithId": "/postWithId?post_id=",
    "postWithUserId": "/postWithUserId?user_id=",
    "myPosts": "/myPosts",
    "followingPosts": "/followingUsersPosts",
    "likedPosts": "/myLikedPosts",
} export const USER_ROUTES = {
    "delete": "/delete",
    "follow": "/follow/toFollowId=",
    "unfollow": "/unfollow/toUnfollowId=",
    "updateBio": "/update/bio",
    "updatePassword": "/update/password",
    "getById": "/get",
    "getByEmail": "/get/email",
}

export const ROUTES = {
    "auth": {
        routes: AUTH_ROUTES,
        url: AUTH_SERVER
    },
    "blogs": {
        routes: BLOGS_ROUTES,
        url: BLOGS_SERVER
    },
    "feed": {
        routes: FEED_ROUTES,
        url: FEED_SERVER
    },
    "user": {
        routes: USER_ROUTES,
        url: USER_SERVER
    }
}Location: ./tmp/git_repo/blogx/frontend/src/constants/api.constants.ts const middleLayer = "/v1/api"

export const AUTH_SERVER = middleLayer + '/auth'
export const BLOGS_SERVER = middleLayer + '/blogs'
export const FEED_SERVER = middleLayer + '/feed'
export const USER_SERVER = middleLayer + '/user'

export const AUTH_ROUTES = {
    "login": "/login", 
    "register": "/register", 
    "logout": "/logout", 
}

export const BLOGS_ROUTES = {
    "addBlog": "/addBlog",
    "updateBlog": "/updateBlog",
    "deleteBlog": "/deleteBlog",
    "likeBlog": "/likeBlog?post_id=",
    "dislikeBlog": "/dislikeBlog?post_id=",
}

export const FEED_ROUTES = {
    "allPosts": "/allPosts",
    "allPostsPageWise": "/allPostsPageWise?page_no=",
    "postWithId": "/postWithId?post_id=",
    "postWithUserId": "/postWithUserId?user_id=",
    "myPosts": "/myPosts",
    "followingPosts": "/followingUsersPosts",
    "likedPosts": "/myLikedPosts",
} export const USER_ROUTES = {
    "delete": "/delete",
    "follow": "/follow/toFollowId=",
    "unfollow": "/unfollow/toUnfollowId=",
    "updateBio": "/update/bio",
    "updatePassword": "/update/password",
    "getById": "/get",
    "getByEmail": "/get/email",
}

export const ROUTES = {
    "auth": {
        routes: AUTH_ROUTES,
        url: AUTH_SERVER
    },
    "blogs": {
        routes: BLOGS_ROUTES,
        url: BLOGS_SERVER
    },
    "feed": {
        routes: FEED_ROUTES,
        url: FEED_SERVER
    },
    "user": {
        routes: USER_ROUTES,
        url: USER_SERVER
    }
}



**************************************************EOF**************************************************const sidebarItems = ['Home', 'Post', 'View', 'Profile', 'Settings', 'Log-out']
const sidebarRoutes = ['/home', '/post', '/view', '/profile', '/settings', '/']

export const SidebarMap :{
    [key: string]: string
} = {
    '/home': 'Home',
    '/post': 'Post',
    '/view': 'View',
    '/profile': 'Profile',
    '/settings': 'Settings',
    '/': 'Log-out'
}

export const SidebarOptions = {
    'items': sidebarItems,
    'routes': sidebarRoutes
}Location: ./tmp/git_repo/blogx/frontend/src/constants/sidebar.constants.ts
const sidebarItems = ['Home', 'Post', 'View', 'Profile', 'Settings', 'Log-out'] const sidebarRoutes = ['/home', '/post', '/view', '/profile', '/settings', '/']

export const SidebarMap :{
    [key: string]: string
} = {
    '/home': 'Home',
    '/post': 'Post',
    '/view': 'View',
    '/profile': 'Profile',
    '/settings': 'Settings',
    '/': 'Log-out'
}

export const SidebarOptions = {
    'items': sidebarItems,
    'routes': sidebarRoutes
}



**************************************************EOF**************************************************declare type LoginData = {
    email: string;
    password: string;
}

declare type RegisterData = {
    username: string;
    email: string;
    password: string;
}Location: ./tmp/git_repo/blogx/frontend/src/types/auth.d.ts
declare type LoginData = {
    email: string;
    password: string;
}

declare type RegisterData = {
    username: string;
    email: string;
    password: string;
}



**************************************************EOF**************************************************declare interface AddBlog {
    "title": string;
    "body": string;
    "tags": !string[];
}

declare interface Blog {
    "id": string;
    "title": string;
    "body": string;
    "tags": !string[];
    "createdAt": !string;
    "views": number;
    "likes": number;
}

declare interface BlogView {
    "id": string;
    "title": string;
    "description": string;
    "body": string;
    "createdAt": !string;
    "views": !number;
    "likes": !number;
    "tags": !string[];
    "image": string;
    "author": string;
}Location: ./tmp/git_repo/blogx/frontend/src/types/blog.d.ts
declare interface AddBlog {
    "title": string;
    "body": string;
    "tags": !string[];
}

declare interface Blog {
    "id": string;
    "title": string;
    "body": string;
    "tags": !string[];
    "createdAt": !string;
    "views": number;
    "likes": number;
} declare interface BlogView {
    "id": string;
    "title": string;
    "description": string;
    "body": string;
    "createdAt": !string;
    "views": !number;
    "likes": !number;
    "tags": !string[];
    "image": string;
    "author": string;
}



**************************************************EOF**************************************************export const handleBold = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "**" + prev.slice(cursorSelectStart, cursorSelectEnd) + "**" + prev.slice(cursorSelectEnd);
    });
};

export const handleItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "*" + prev.slice(cursorSelectStart, cursorSelectEnd) + "*" + prev.slice(cursorSelectEnd);
    });
}

export const handleBoldItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "***" + prev.slice(cursorSelectStart, cursorSelectEnd) + "***" + prev.slice(cursorSelectEnd);
    });
} export const handleUnderline = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "__" + prev.slice(cursorSelectStart, cursorSelectEnd) + "__" + prev.slice(cursorSelectEnd);
    });
}

export const handleHeadings = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, headingLevel: number) => {
    const heading = "#".repeat(headingLevel);
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + heading + " " + prev.slice(cursorSelectStart, cursorSelectEnd) + prev.slice(cursorSelectEnd);
    });
} export const handlerLinks = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, link: string) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "[" + prev.slice(cursorSelectStart, cursorSelectEnd) + "](" + link + ")" + prev.slice(cursorSelectEnd);
    });
}

export const handleCodeBlock = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "```" + prev.slice(cursorSelectStart, cursorSelectEnd) + "```" + prev.slice(cursorSelectEnd);
    });
} export const handleHighlight = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "`" + prev.slice(cursorSelectStart, cursorSelectEnd) + "`" + prev.slice(cursorSelectEnd);
    });
}

export const handleNewLine = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "\n <br />\n" + prev.slice(cursorSelectStart);
    });
}Location: ./tmp/git_repo/blogx/frontend/src/utils/markdown.ts
export const handleBold = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "**" + prev.slice(cursorSelectStart, cursorSelectEnd) + "**" + prev.slice(cursorSelectEnd);
    });
}; export const handleItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "*" + prev.slice(cursorSelectStart, cursorSelectEnd) + "*" + prev.slice(cursorSelectEnd);
    });
}

export const handleBoldItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "***" + prev.slice(cursorSelectStart, cursorSelectEnd) + "***" + prev.slice(cursorSelectEnd);
    });
}

export const handleUnderline = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "__" + prev.slice(cursorSelectStart, cursorSelectEnd) + "__" + prev.slice(cursorSelectEnd);
    });
} export const handleHeadings = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, headingLevel: number) => {
    const heading = "#".repeat(headingLevel);
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + heading + " " + prev.slice(cursorSelectStart, cursorSelectEnd) + prev.slice(cursorSelectEnd);
    });
}

export const handlerLinks = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, link: string) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "[" + prev.slice(cursorSelectStart, cursorSelectEnd) + "](" + link + ")" + prev.slice(cursorSelectEnd);
    });
} export const handleCodeBlock = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "```" + prev.slice(cursorSelectStart, cursorSelectEnd) + "```" + prev.slice(cursorSelectEnd);
    });
}

export const handleHighlight = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "`" + prev.slice(cursorSelectStart, cursorSelectEnd) + "`" + prev.slice(cursorSelectEnd);
    });
}

export const handleNewLine = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "\n <br />\n" + prev.slice(cursorSelectStart);
    });
} **************************************************EOF**************************************************defaults
         log     global
        mode    http
        option  httplog
        option  dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
 resolvers docker
         parse-resolv-conf
 frontend http-in
         bind *:80 
 
        use_backend authentication if { path_beg /v1/api/auth }
        use_backend blogs if { path_beg /v1/api/blogs }
        use_backend feed if { path_beg /v1/api/feed }
        use_backend user if { path_beg /v1/api/user }
 backend authentication
         balance roundrobin
        server auth_server auth:8080 
 backend blogs
         balance roundrobin
        server blogs_server blog:8081 
 backend feed
         balance roundrobin
        server feed_server feed:8082
 backend user
         balance roundrobin
        server user_server user:8083
 Location: ./tmp/git_repo/blogx/haproxy/haproxy.cfg
 defaults
         log     global
        mode    http
        option  httplog
        option  dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
 resolvers docker
         parse-resolv-conf
 frontend http-in
         bind *:80 
 
        use_backend authentication if { path_beg /v1/api/auth }
        use_backend blogs if { path_beg /v1/api/blogs }
        use_backend feed if { path_beg /v1/api/feed }
        use_backend user if { path_beg /v1/api/user }
 backend authentication
         balance roundrobin
        server auth_server auth:8080 
 backend blogs
         balance roundrobin
        server blogs_server blog:8081 
 backend feed
         balance roundrobin
        server feed_server feed:8082
 backend user
         balance roundrobin
        server user_server user:8083
 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-auth
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-auth
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8080"
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_auth:0.0
           name: auth
           ports:
             - containerPort: 8080
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-auth-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-auth
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-auth
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8080"
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_auth:0.0
           name: auth
           ports:
             - containerPort: 8080
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-blog
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-blog
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8081"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_blog:0.0
           name: blog
           ports:
             - containerPort: 8081
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-blog-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-blog
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-blog
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8081"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_blog:0.0
           name: blog
           ports:
             - containerPort: 8081
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-feed
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-feed
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8082"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_feed:0.0
           name: feed
           ports:
             - containerPort: 8082
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-feed-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-feed
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-feed
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8082"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_feed:0.0
           name: feed
           ports:
             - containerPort: 8082
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 ports:
     - name: "8080"
       port: 8080
       targetPort: 8080
   selector:
     io.kompose.service: api-auth
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_auth-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 ports:
     - name: "8080"
       port: 8080
       targetPort: 8080
   selector:
     io.kompose.service: api-auth
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 ports:
     - name: "8081"
       port: 8081
       targetPort: 8081
   selector:
     io.kompose.service: api-blog
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_blog-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 ports:
     - name: "8081"
       port: 8081
       targetPort: 8081
   selector:
     io.kompose.service: api-blog
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 ports:
     - name: "8082"
       port: 8082
       targetPort: 8082
   selector:
     io.kompose.service: api-feed
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_feed-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 ports:
     - name: "8082"
       port: 8082
       targetPort: 8082
   selector:
     io.kompose.service: api-feed
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-user
   name: api-user
 spec:
 ports:
     - name: "8083"
       port: 8083
       targetPort: 8083
   selector:
     io.kompose.service: api-user
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_user-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-user
   name: api-user
 spec:
 ports:
     - name: "8083"
       port: 8083
       targetPort: 8083
   selector:
     io.kompose.service: api-user
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: networking.k8s.io/v1
 kind: NetworkPolicy
 metadata:
 creationTimestamp: null
   name: blogx-backend-go-default
 spec:
 ingress:
     - from:
         - podSelector:
             matchLabels:
               io.kompose.network/blogx-backend-go-default: "true"
   podSelector:
     matchLabels:
       io.kompose.network/blogx-backend-go-default: "true"
 Location: ./tmp/git_repo/blogx/k8s/blogx-backend-go-default-networkpolicy.yaml
 apiVersion: networking.k8s.io/v1
 kind: NetworkPolicy
 metadata:
 creationTimestamp: null
   name: blogx-backend-go-default
 spec:
 ingress:
     - from:
         - podSelector:
             matchLabels:
               io.kompose.network/blogx-backend-go-default: "true"
   podSelector:
     matchLabels:
       io.kompose.network/blogx-backend-go-default: "true"




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: haproxy
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: haproxy
     spec:
       containers:
         - image: sohamkr/blogx_haproxy:0.0
           name: haproxy
           ports:
             - containerPort: 80
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/haproxy-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: haproxy
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: haproxy
     spec:
       containers:
         - image: sohamkr/blogx_haproxy:0.0
           name: haproxy
           ports:
             - containerPort: 80
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 ports:
     - name: "8000"
       port: 8000
       targetPort: 80
   selector:
     io.kompose.service: haproxy
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/haproxy-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 ports:
     - name: "8000"
       port: 8000
       targetPort: 80
   selector:
     io.kompose.service: haproxy
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: PersistentVolumeClaim
 metadata:
 creationTimestamp: null
   labels:
     io.kompose.service: postgres-claim1
   name: postgres-claim1
 spec:
 accessModes:
     - ReadWriteOnce
   resources:
     requests:
       storage: 100Mi
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/postgres-claim1-persistentvolumeclaim.yaml
 apiVersion: v1
 kind: PersistentVolumeClaim
 metadata:
 creationTimestamp: null
   labels:
     io.kompose.service: postgres-claim1
   name: postgres-claim1
 spec:
 accessModes:
     - ReadWriteOnce
   resources:
     requests:
       storage: 100Mi
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: postgres
   name: postgres
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: postgres
   strategy:
     type: Recreate
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: postgres
     spec:
       containers:
         - env:
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: postgres:15.1-alpine
           name: db
           ports:
             - containerPort: 5432
           resources: {}
           volumeMounts:
             - mountPath: /var/lib/postgresql/data
               name: pg-data-blogx
             - mountPath: /docker-entrypoint-initdb.d/init.sql
               name: postgres-claim1
       restartPolicy: Always
       volumes:
         - name: pg-data-blogx
           persistentVolumeClaim:
             claimName: pg-data-blogx
         - name: postgres-claim1
           persistentVolumeClaim:
             claimName: postgres-claim1
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/postgres-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: postgres
   name: postgres
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: postgres
   strategy:
     type: Recreate
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: postgres
     spec:
       containers:
         - env:
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: postgres:15.1-alpine
           name: db
           ports:
             - containerPort: 5432
           resources: {}
           volumeMounts:
             - mountPath: /var/lib/postgresql/data
               name: pg-data-blogx
             - mountPath: /docker-entrypoint-initdb.d/init.sql
               name: postgres-claim1
       restartPolicy: Always
       volumes:
         - name: pg-data-blogx
           persistentVolumeClaim:
             claimName: pg-data-blogx
         - name: postgres-claim1
           persistentVolumeClaim:
             claimName: postgres-claim1
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: redis
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: redis
     spec:
       containers:
         - image: redis:7-alpine
           name: redis
           ports:
             - containerPort: 6379
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/redis-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: redis
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: redis
     spec:
       containers:
         - image: redis:7-alpine
           name: redis
           ports:
             - containerPort: 6379
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 ports:
     - name: "6379"
       port: 6379
       targetPort: 6379
   selector:
     io.kompose.service: redis
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/redis-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 ports:
     - name: "6379"
       port: 6379
       targetPort: 6379
   selector:
     io.kompose.service: redis
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: swagger-ui
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: swagger-ui
     spec:
       containers:
         - image: sohamkr/blogx_swagger:0.0
           name: swagger
           ports:
             - containerPort: 8084
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/swagger-ui-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: swagger-ui
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: swagger-ui
     spec:
       containers:
         - image: sohamkr/blogx_swagger:0.0
           name: swagger
           ports:
             - containerPort: 8084
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 ports:
     - name: "8084"
       port: 8084
       targetPort: 8084
   selector:
     io.kompose.service: swagger-ui
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/swagger_ui-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 ports:
     - name: "8084"
       port: 8084
       targetPort: 8084
   selector:
     io.kompose.service: swagger-ui
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-auth
   template:
     metadata:
       labels:
         app: api-auth
     spec:
       containers:
       - name: api-auth
         image: sohamkr/blogx_auth:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8080"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8080
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8080
     targetPort: 8080
   selector:
     app: api-auth

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-auth-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-auth
   minReplicas: 2
   maxReplicas: 5
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70Location: ./tmp/git_repo/blogx/k8s/updated/api_auth_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-auth
   template:
     metadata:
       labels:
         app: api-auth
     spec:
       containers:
       - name: api-auth
         image: sohamkr/blogx_auth:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8080"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8080
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8080
     targetPort: 8080
   selector:
     app: api-auth

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-auth-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-auth
   minReplicas: 2
   maxReplicas: 5
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70



 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-feed
   template:
     metadata:
       labels:
         app: api-feed
     spec:
       containers:
       - name: api-feed
         image: sohamkr/blogx_feed:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8082"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8082
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8082
     targetPort: 8082
   selector:
     app: api-feed

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-feed-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-feed
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
 Location: ./tmp/git_repo/blogx/k8s/updated/api_feed_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-feed
   template:
     metadata:
       labels:
         app: api-feed
     spec:
       containers:
       - name: api-feed
         image: sohamkr/blogx_feed:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8082"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8082
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8082
     targetPort: 8082
   selector:
     app: api-feed

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-feed-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-feed
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-user
   template:
     metadata:
       labels:
         app: api-user
     spec:
       containers:
       - name: api-user
         image: sohamkr/blogx_user:0.1
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8083"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8083
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8083
     targetPort: 8083
   selector:
     app: api-user

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-user-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-user
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
 Location: ./tmp/git_repo/blogx/k8s/updated/api_user_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-user
   template:
     metadata:
       labels:
         app: api-user
     spec:
       containers:
       - name: api-user
         image: sohamkr/blogx_user:0.1
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8083"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8083
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8083
     targetPort: 8083
   selector:
     app: api-user

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-user-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-user
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: haproxy
   template:
     metadata:
       labels:
         app: haproxy
     spec:
       containers:
       - name: haproxy
         image: sohamkr/blogx_haproxy:0.0
         ports:
         - containerPort: 80

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 ports:
   - port: 80
     targetPort: 80
   selector:
     app: haproxy
   type: LoadBalancer
 Location: ./tmp/git_repo/blogx/k8s/updated/haproxy_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: haproxy
   template:
     metadata:
       labels:
         app: haproxy
     spec:
       containers:
       - name: haproxy
         image: sohamkr/blogx_haproxy:0.0
         ports:
         - containerPort: 80

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 ports:
   - port: 80
     targetPort: 80
   selector:
     app: haproxy
   type: LoadBalancer




 **************************************************EOF**************************************************
Location: ./tmp/git_repo/blogx/k8s/updated/redis_manifest.yaml




 **************************************************EOF**************************************************
package main

import (
	_ "github.com/SohamRatnaparkhi/blogx-backend-go/swagger/docs"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func main() {
	r := gin.Default()
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	r.Run(":8084")
}
Location: ./tmp/git_repo/blogx/swagger/main.go
package main

import (
	_ "github.com/SohamRatnaparkhi/blogx-backend-go/swagger/docs"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func main() {
	r := gin.Default()
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	r.Run(":8084")
}




**************************************************EOF**************************************************// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag" const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Login a user with email and password given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse" }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Logout a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "202": {
                        "description": "Accepted", "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a user with fist name, last name, email, password and bio given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [ "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "parameters": [
                    {
                        "description": "User details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema"
                        }
                    },
                    "400": { "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/addBlog": {
            "post": {
                "description": "Create a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data", "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/deleteBlog": {
            "delete": {
                "description": "Delete a post with post id given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    }, "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/dislike": {
            "get": {
                "description": "dislike a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": { "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/like": {
            "get": {
                "description": "Like a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ], "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/updateBlog": {
            "patch": {
                "description": "Update a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams"
                        }
                    }
                ], "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isadmin": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema": {
            "type": "object",
            "properties": {
                "bio": {
                    "$ref": "#/definitions/sql.NullString"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": { "type": "string"
                },
                "is_admin": {
                    "type": "boolean"
                },
                "last_name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                } }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "string"
                },
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string" },
                "likes": {
                    "type": "integer"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "sql.NullString": {
            "type": "object",
            "properties": {
                "string": {
                    "type": "string"
                },
                "valid": {
                    "description": "Valid is true if String is not NULL",
                    "type": "boolean"
                }
            }
        }
    }
}` // SwaggerInfo holds exported Swagger Info so clients can modify it var SwaggerInfo = &swag.Spec{
	Version:          "",
	Host:             "127.0.0.1:8000",
	BasePath:         "/v1/api",
	Schemes:          []string{},
	Title:            "Authentication server",
	Description:      "This is the authentication server for blogx",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
} func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
Location: ./tmp/git_repo/blogx/swagger/docs/docs.go
// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag" const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Login a user with email and password given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse" }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Logout a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "202": {
                        "description": "Accepted", "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a user with fist name, last name, email, password and bio given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [ "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "parameters": [
                    {
                        "description": "User details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema"
                        }
                    },
                    "400": { "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/addBlog": {
            "post": {
                "description": "Create a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data", "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/deleteBlog": {
            "delete": {
                "description": "Delete a post with post id given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    }, "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/dislike": {
            "get": {
                "description": "dislike a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": { "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/like": {
            "get": {
                "description": "Like a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ], "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/updateBlog": {
            "patch": {
                "description": "Update a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams"
                        }
                    }
                ], "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isadmin": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema": {
            "type": "object",
            "properties": {
                "bio": {
                    "$ref": "#/definitions/sql.NullString"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": { "type": "string"
                },
                "is_admin": {
                    "type": "boolean"
                },
                "last_name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                } }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "string"
                },
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string" },
                "likes": {
                    "type": "integer"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "sql.NullString": {
            "type": "object",
            "properties": {
                "string": {
                    "type": "string"
                },
                "valid": {
                    "description": "Valid is true if String is not NULL",
                    "type": "boolean"
                }
            }
        }
    }
}` // SwaggerInfo holds exported Swagger Info so clients can modify it var SwaggerInfo = &swag.Spec{
	Version:          "",
	Host:             "127.0.0.1:8000",
	BasePath:         "/v1/api",
	Schemes:          []string{},
	Title:            "Authentication server",
	Description:      "This is the authentication server for blogx",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
} func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}




**************************************************EOF**************************************************basePath: /v1/api
 definitions:
 github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       createdAt:
         type: string
       email:
         type: string
       firstName:
         type: string
       id:
         type: string
       isadmin:
         type: boolean
       lastName:
         type: string
       password:
         type: string
       updatedAt:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       last_name:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       created_at:
         type: string
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       is_admin:
         type: boolean
       last_name:
         type: string
       updated_at:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       userID:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap:
     properties:
       author_id:
         type: string
       body:
         type: string
       id:
         type: string
       likes:
         type: integer
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       views:
         type: integer
     type: object
   sql.NullString:
     properties:
       string:
         type: string
       valid:
         description: Valid is true if String is not NULL
         type: boolean
     type: object
 host: 127.0.0.1:8000
 info:
 contact: {}
   description: This is the authentication server for blogx
   title: Authentication server
 paths:
 /auth/login:
     post:
       consumes:
       - application/json
       description: Login a user with email and password given in the body
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/logout:
     post:
       consumes:
       - application/json
       description: Logout a user
       produces:
       - application/json
       responses:
         "202":
           description: Accepted
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/register:
     post:
       consumes:
       - application/json
       description: Register a user with fist name, last name, email, password and
         bio given in the body
       parameters:
       - description: User details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /blogs/addBlog:
     post:
       consumes:
       - application/json
       description: Create a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/deleteBlog:
     delete:
       consumes:
       - application/json
       description: Delete a post with post id given in the body
       produces:
       - application/json
       responses:
         "204":
           description: No Content
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/dislike:
     get:
       consumes:
       - application/json
       description: dislike a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/like:
     get:
       consumes:
       - application/json
       description: Like a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/updateBlog:
     patch:
       consumes:
       - application/json
       description: Update a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
 swagger: "2.0"
 Location: ./tmp/git_repo/blogx/swagger/docs/swagger.yaml
 basePath: /v1/api
 definitions:
 github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       createdAt:
         type: string
       email:
         type: string
       firstName:
         type: string
       id:
         type: string
       isadmin:
         type: boolean
       lastName:
         type: string
       password:
         type: string
       updatedAt:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       last_name:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       created_at:
         type: string
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       is_admin:
         type: boolean
       last_name:
         type: string
       updated_at:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       userID:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap:
     properties:
       author_id:
         type: string
       body:
         type: string
       id:
         type: string
       likes:
         type: integer
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       views:
         type: integer
     type: object
   sql.NullString:
     properties:
       string:
         type: string
       valid:
         description: Valid is true if String is not NULL
         type: boolean
     type: object
 host: 127.0.0.1:8000
 info:
 contact: {}
   description: This is the authentication server for blogx
   title: Authentication server
 paths:
 /auth/login:
     post:
       consumes:
       - application/json
       description: Login a user with email and password given in the body
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/logout:
     post:
       consumes:
       - application/json
       description: Logout a user
       produces:
       - application/json
       responses:
         "202":
           description: Accepted
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/register:
     post:
       consumes:
       - application/json
       description: Register a user with fist name, last name, email, password and
         bio given in the body
       parameters:
       - description: User details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /blogs/addBlog:
     post:
       consumes:
       - application/json
       description: Create a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/deleteBlog:
     delete:
       consumes:
       - application/json
       description: Delete a post with post id given in the body
       produces:
       - application/json
       responses:
         "204":
           description: No Content
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/dislike:
     get:
       consumes:
       - application/json
       description: dislike a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/like:
     get:
       consumes:
       - application/json
       description: Like a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/updateBlog:
     patch:
       consumes:
       - application/json
       description: Update a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
 swagger: "2.0"




 **************************************************EOF**************************************************
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()

	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nUser server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	} fmt.Printf("Server started at PORT %v", PORT)
}
Location: ./tmp/git_repo/blogx/user/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()

	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nUser server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Server started at PORT %v", PORT)
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/user/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/user/db/database/feed.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}
Location: ./tmp/git_repo/blogx/user/db/database/follower.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/user/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/user/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE users SET bio = $1 WHERE id = $2
` func (q *Queries) UpdateUserBio(ctx context.Context, bio sql.NullString, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserBio, bio, id)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users SET email = $1 WHERE id = $2
`

func (q *Queries) UpdateUserEmail(ctx context.Context, email string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, email, id)
	return err
}

const updateUserFirstName = `-- name: UpdateUserFirstName :exec
UPDATE users SET first_name = $1 WHERE id = $2
`

func (q *Queries) UpdateUserFirstName(ctx context.Context, firstName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserFirstName, firstName, id)
	return err
}

const updateUserLastName = `-- name: UpdateUserLastName :exec
UPDATE users SET last_name = $1 WHERE id = $2
` func (q *Queries) UpdateUserLastName(ctx context.Context, lastName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserLastName, lastName, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password = $1 WHERE id = $2 && email = $3
` func (q *Queries) UpdateUserPassword(ctx context.Context, password string, id uuid.UUID, email string) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, password, id, email)
	return err
}Location: ./tmp/git_repo/blogx/user/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE users SET bio = $1 WHERE id = $2
` func (q *Queries) UpdateUserBio(ctx context.Context, bio sql.NullString, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserBio, bio, id)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users SET email = $1 WHERE id = $2
`

func (q *Queries) UpdateUserEmail(ctx context.Context, email string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, email, id)
	return err
}

const updateUserFirstName = `-- name: UpdateUserFirstName :exec
UPDATE users SET first_name = $1 WHERE id = $2
`

func (q *Queries) UpdateUserFirstName(ctx context.Context, firstName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserFirstName, firstName, id)
	return err
}

const updateUserLastName = `-- name: UpdateUserLastName :exec
UPDATE users SET last_name = $1 WHERE id = $2
` func (q *Queries) UpdateUserLastName(ctx context.Context, lastName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserLastName, lastName, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password = $1 WHERE id = $2 && email = $3
`

func (q *Queries) UpdateUserPassword(ctx context.Context, password string, id uuid.UUID, email string) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, password, id, email)
	return err
}



**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/user/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func DeleteUser(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user_uuid := user.ID
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})

	err := apiConfig.DeleteUser(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/DeleteUser.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func DeleteUser(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user_uuid := user.ID
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})

	err := apiConfig.DeleteUser(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/google/uuid"
)

func FollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toFollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.FollowUser(req.Context(), database.FollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
} func UnFollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toUnfollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.UnfollowUser(req.Context(), database.UnfollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/Folllow.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/google/uuid"
) func FollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toFollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.FollowUser(req.Context(), database.FollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
} func UnFollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toUnfollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.UnfollowUser(req.Context(), database.UnfollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func GetUserByID(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByID(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
} func GetUserByEmail(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByEmail(req.Context(), user.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/GetUser.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func GetUserByID(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByID(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
} func GetUserByEmail(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByEmail(req.Context(), user.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
}




**************************************************EOF**************************************************package users

import (
	"database/sql"
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func UpdateUserBio(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Bio sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserBio(req.Context(), reqBodyDecoded.Bio, user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Bio updated successfully",
	})
} func UpdateUserPassword(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Password string `json:"password"`
		Email    string `json:"email"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserPassword(req.Context(), reqBodyDecoded.Password, user.ID, reqBodyDecoded.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Password updated successfully",
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/Update.go
package users

import (
	"database/sql"
	"encoding/json"
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func UpdateUserBio(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Bio sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserBio(req.Context(), reqBodyDecoded.Bio, user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Bio updated successfully",
	})
} func UpdateUserPassword(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Password string `json:"password"`
		Email    string `json:"email"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserPassword(req.Context(), reqBodyDecoded.Password, user.ID, reqBodyDecoded.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Password updated successfully",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/user/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	userRouter := SetUserRouter()
	apiRouter.Mount("/user", userRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/user/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	userRouter := SetUserRouter()
	apiRouter.Mount("/user", userRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	users "github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/user"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/middleware"
	"github.com/go-chi/chi"
) func SetUserRouter() chi.Router {
	var userRouter = chi.NewRouter()
	userRouter.Get("/", server.HealthCheck)
	userRouter.Delete("/delete", middleware.Auth(middleware.AuthHandler(users.DeleteUser)))
	userRouter.Post("/follow", middleware.Auth(middleware.AuthHandler(users.FollowUser)))
	userRouter.Post("/unfollow", middleware.Auth(middleware.AuthHandler(users.UnFollowUser)))
	userRouter.Post("/update/bio", middleware.Auth(middleware.AuthHandler(users.UpdateUserBio)))
	userRouter.Post("/update/password", middleware.Auth(middleware.AuthHandler(users.UpdateUserPassword)))
	userRouter.Get("/get", middleware.Auth(middleware.AuthHandler(users.GetUserByID)))
	userRouter.Get("/get/email", middleware.Auth(middleware.AuthHandler(users.GetUserByEmail)))
	return userRouter
}
Location: ./tmp/git_repo/blogx/user/pkg/routers/User.go
package routers import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	users "github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/user"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/middleware"
	"github.com/go-chi/chi"
) func SetUserRouter() chi.Router {
	var userRouter = chi.NewRouter()
	userRouter.Get("/", server.HealthCheck)
	userRouter.Delete("/delete", middleware.Auth(middleware.AuthHandler(users.DeleteUser)))
	userRouter.Post("/follow", middleware.Auth(middleware.AuthHandler(users.FollowUser)))
	userRouter.Post("/unfollow", middleware.Auth(middleware.AuthHandler(users.UnFollowUser)))
	userRouter.Post("/update/bio", middleware.Auth(middleware.AuthHandler(users.UpdateUserBio)))
	userRouter.Post("/update/password", middleware.Auth(middleware.AuthHandler(users.UpdateUserPassword)))
	userRouter.Get("/get", middleware.Auth(middleware.AuthHandler(users.GetUserByID)))
	userRouter.Get("/get/email", middleware.Auth(middleware.AuthHandler(users.GetUserByEmail)))
	return userRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
} func MapLoginUser(dbUser database.User) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
	}
}
Location: ./tmp/git_repo/blogx/user/pkg/utils/UserMap.go
package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
}

func MapLoginUser(dbUser database.User) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
	}
}




**************************************************EOF**************************************************version: '3.9'
 services:
 postgres:
     container_name: db
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - POSTGRES_DB=blogx_db
     volumes:
       - 'pg_data_blogx:/var/lib/postgresql/data'
       - './db/init.sql:/docker-entrypoint-initdb.d/init.sql'
     ports:
       - '5432:5432'
     restart: always
     image: 'postgres:15.1-alpine'
   redis:
     container_name: redis
     network_mode: my-network
     ports:
       - '6379:6379'
     restart: always
     image: 'redis:7-alpine'

   haproxy:
     container_name: haproxy
     network_mode: my-network
     ports:
       - '8000:80'
     restart: always
     image: sohamkr/blogx_haproxy:0.0
     # build:
     #   context: ./haproxy/
     #   dockerfile: Dockerfile
   api_auth:
     container_name: auth
     network_mode: my-network
     environment:
       - POSTGRES_DB=blogx_db
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8080
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8080:8080'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_auth:0.0'
     # build:
     #   context: ./authentication/
     #   dockerfile: Dockerfile
   api_blog:
     container_name: blog
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8081
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8081:8081'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_blog:0.0'
     # build:
       # context: ./blog/
       # dockerfile: Dockerfile
   api_feed:
     container_name: feed
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8082
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8082:8082'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_feed:0.0'
     # build:
       # context: ./feed/
       # dockerfile: Dockerfile
   api_user:
     container_name: user
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8083
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8083:8083'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_user:0.1'
     # build:
       # context: ./user/
       # dockerfile: Dockerfile
   swagger_ui:
     container_name: swagger
     network_mode: my-network
     ports:
       - '8084:8084'
     restart: always
     image: 'sohamkr/blogx_swagger:0.0'
     # build:
       # context: ./swagger/
       # dockerfile: Dockerfile
 volumes:
 pg_data_blogx:
 networks:
 my-network:
     driver: bridge
 Location: ./tmp/git_repo/blogx/docker-compose.yaml
 version: '3.9'
 services:
 postgres:
     container_name: db
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - POSTGRES_DB=blogx_db
     volumes:
       - 'pg_data_blogx:/var/lib/postgresql/data'
       - './db/init.sql:/docker-entrypoint-initdb.d/init.sql'
     ports:
       - '5432:5432'
     restart: always
     image: 'postgres:15.1-alpine'
   redis:
     container_name: redis
     network_mode: my-network
     ports:
       - '6379:6379'
     restart: always
     image: 'redis:7-alpine'

   haproxy:
     container_name: haproxy
     network_mode: my-network
     ports:
       - '8000:80'
     restart: always
     image: sohamkr/blogx_haproxy:0.0
     # build:
     #   context: ./haproxy/
     #   dockerfile: Dockerfile
   api_auth:
     container_name: auth
     network_mode: my-network
     environment:
       - POSTGRES_DB=blogx_db
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8080
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8080:8080'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_auth:0.0'
     # build:
     #   context: ./authentication/
     #   dockerfile: Dockerfile
   api_blog:
     container_name: blog
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8081
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8081:8081'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_blog:0.0'
     # build:
       # context: ./blog/
       # dockerfile: Dockerfile
   api_feed:
     container_name: feed
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8082
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8082:8082'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_feed:0.0'
     # build:
       # context: ./feed/
       # dockerfile: Dockerfile
   api_user:
     container_name: user
     network_mode: my-network
     environment:
       - POSTGRES_PASSWORD=foobarbaz
       - DB_HOST=db
       - DB_PORT=5432
       - DB_USER=postgres
       - DB_PASSWORD=foobarbaz
       - DB_NAME=blogx_db
       - PORT=8083
       - JWT_SECRET_KEY=blogx_secret_key
       - BCRYPT_SALT_VALUE=12
       - 'DB_URL=postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable'
     ports:
       - '8083:8083'
     restart: always
     links:
       - postgres
     image: 'sohamkr/blogx_user:0.1'
     # build:
       # context: ./user/
       # dockerfile: Dockerfile
   swagger_ui:
     container_name: swagger
     network_mode: my-network
     ports:
       - '8084:8084'
     restart: always
     image: 'sohamkr/blogx_swagger:0.0'
     # build:
       # context: ./swagger/
       # dockerfile: Dockerfile
 volumes:
 pg_data_blogx:
 networks:
 my-network:
     driver: bridge




 **************************************************EOF**************************************************
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Authentication server
// @description This is the authentication server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nAuthentication server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe() if err != nil {
		log.Fatal(err)
	}
}
Location: ./tmp/git_repo/blogx/authentication/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Authentication server
// @description This is the authentication server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nAuthentication server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/authentication/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}
Location: ./tmp/git_repo/blogx/authentication/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/authentication/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
) const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/authentication/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package users

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"os"
	"strconv"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Register a user
// @version 1
// @description Register a user with fist name, last name, email, password and bio given in the body
// @Tags authentication
// @accept json
// @param data body database.User true "User details"
// @produce json
// @success 201 {object} utils.DbUserFullSchema
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/register [post] func HandleRegisterUser(w http.ResponseWriter, req *http.Request) {
	type reqBody struct {
		FirstName string         `json:"first_name"`
		LastName  string         `json:"last_name"`
		Email     string         `json:"email"`
		Password  string         `json:"password"`
		Bio       sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	apiConfig := pkg.DbInstance()
	// fmt.Println(&apiConfig)

	saltValueString := os.Getenv("BCRYPT_SALT_VALUE")

	saltValue, bcryptErr := strconv.Atoi(saltValueString)

	if bcryptErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, bcryptErr)
		return
	}
	hashedPassword, err2 := bcrypt.GenerateFromPassword([]byte(bodyDecoded.Password), saltValue)
	if err2 != nil {
		hashedPassword = []byte(bodyDecoded.Password)
	} user, failedToAddToDb := apiConfig.CreateUser(
		req.Context(),
		database.CreateUserParams{
			ID:        uuid.New(),
			FirstName: bodyDecoded.FirstName,
			LastName:  bodyDecoded.LastName,
			Email:     bodyDecoded.Email,
			Password:  string(hashedPassword),
			Bio:       bodyDecoded.Bio,
		},
	)

	if failedToAddToDb != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, failedToAddToDb)
		return
	}

	// create jwt token
	token, expiryTime, jwtTokenError := utils.GetJwt(utils.Credentials{
		Email: bodyDecoded.Email,
		Name:  user.FirstName + user.LastName,
	})

	if jwtTokenError != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, jwtTokenError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   token,
		Expires: expiryTime,
		Path:    "/",
	})

	utils.ResponseJson(w, http.StatusCreated, utils.MapRegisteredUser(user))
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/auth/CreateUser.go
package users import (
	"database/sql"
	"encoding/json"
	"net/http"
	"os"
	"strconv"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Register a user
// @version 1
// @description Register a user with fist name, last name, email, password and bio given in the body
// @Tags authentication
// @accept json
// @param data body database.User true "User details"
// @produce json
// @success 201 {object} utils.DbUserFullSchema
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/register [post] func HandleRegisterUser(w http.ResponseWriter, req *http.Request) {
	type reqBody struct {
		FirstName string         `json:"first_name"`
		LastName  string         `json:"last_name"`
		Email     string         `json:"email"`
		Password  string         `json:"password"`
		Bio       sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	apiConfig := pkg.DbInstance()
	// fmt.Println(&apiConfig)

	saltValueString := os.Getenv("BCRYPT_SALT_VALUE")

	saltValue, bcryptErr := strconv.Atoi(saltValueString)

	if bcryptErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, bcryptErr)
		return
	}
	hashedPassword, err2 := bcrypt.GenerateFromPassword([]byte(bodyDecoded.Password), saltValue)
	if err2 != nil {
		hashedPassword = []byte(bodyDecoded.Password)
	} user, failedToAddToDb := apiConfig.CreateUser(
		req.Context(),
		database.CreateUserParams{
			ID:        uuid.New(),
			FirstName: bodyDecoded.FirstName,
			LastName:  bodyDecoded.LastName,
			Email:     bodyDecoded.Email,
			Password:  string(hashedPassword),
			Bio:       bodyDecoded.Bio,
		},
	)

	if failedToAddToDb != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, failedToAddToDb)
		return
	}

	// create jwt token
	token, expiryTime, jwtTokenError := utils.GetJwt(utils.Credentials{
		Email: bodyDecoded.Email,
		Name:  user.FirstName + user.LastName,
	})

	if jwtTokenError != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, jwtTokenError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   token,
		Expires: expiryTime,
		Path:    "/",
	})

	utils.ResponseJson(w, http.StatusCreated, utils.MapRegisteredUser(user))
}




**************************************************EOF**************************************************package users

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Login a user
// @version 1
// @description Login a user with email and password given in the body
// @Tags authentication
// @accept json
// @produce json
// @success 200 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/login [post] func HandleLoginUser(w http.ResponseWriter, req *http.Request) {
	type ReqBody struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	decoder := json.NewDecoder(req.Body)
	body := ReqBody{}

	err := decoder.Decode(&body)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
	}

	apiConfig := pkg.DbClient

	user, err := apiConfig.GetUserByEmail(req.Context(), body.Email)

	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	authCheck := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(body.Password))

	if authCheck != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, authCheck)
		return
	}

	jwtToken, expiryTime, tokenErr := utils.GetJwt(utils.Credentials{
		Email: user.Email,
		Name:  user.FirstName + user.LastName,
	})

	if tokenErr != nil {
		utils.ErrorResponse(w, http.StatusForbidden, tokenErr)
		return
	} http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   jwtToken,
		Expires: expiryTime,
		Path:    "/",
	})

	// go utils.SendMail(user.Email, fmt.Sprintf("Some on logged in to your account at %v", time.Now()), "Login Verification")

	utils.ResponseJson(w, http.StatusOK, utils.MapLoginUser(user, jwtToken))
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/auth/LoginUser.go
package users

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"golang.org/x/crypto/bcrypt"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Login a user
// @version 1
// @description Login a user with email and password given in the body
// @Tags authentication
// @accept json
// @produce json
// @success 200 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/login [post] func HandleLoginUser(w http.ResponseWriter, req *http.Request) {
	type ReqBody struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	decoder := json.NewDecoder(req.Body)
	body := ReqBody{}

	err := decoder.Decode(&body)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
	}

	apiConfig := pkg.DbClient

	user, err := apiConfig.GetUserByEmail(req.Context(), body.Email)

	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	authCheck := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(body.Password))

	if authCheck != nil {
		utils.ErrorResponse(w, http.StatusUnauthorized, authCheck)
		return
	}

	jwtToken, expiryTime, tokenErr := utils.GetJwt(utils.Credentials{
		Email: user.Email,
		Name:  user.FirstName + user.LastName,
	})

	if tokenErr != nil {
		utils.ErrorResponse(w, http.StatusForbidden, tokenErr)
		return
	} http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   jwtToken,
		Expires: expiryTime,
		Path:    "/",
	})

	// go utils.SendMail(user.Email, fmt.Sprintf("Some on logged in to your account at %v", time.Now()), "Login Verification")

	utils.ResponseJson(w, http.StatusOK, utils.MapLoginUser(user, jwtToken))
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Logout a user
// @version 1
// @description Logout a user
// @Tags authentication
// @accept json
// @produce json
// @success 202 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/logout [post] func HandleUserLogout(w http.ResponseWriter, _ *http.Request, user database.User) {
	//clear cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})
	utils.ResponseJson(w, http.StatusAccepted, utils.MapLoginUser(user, ""))
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/auth/LogoutUser.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

// @title Logout a user
// @version 1
// @description Logout a user
// @Tags authentication
// @accept json
// @produce json
// @success 202 {object} utils.DBUserResponse
// @failure 400 {object} string
// @failure 500 {object} string
// @router /auth/logout [post] func HandleUserLogout(w http.ResponseWriter, _ *http.Request, user database.User) {
	//clear cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})
	utils.ResponseJson(w, http.StatusAccepted, utils.MapLoginUser(user, ""))
}




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/authentication/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/authentication/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	authRouter := SetAuthRouter()
	apiRouter.Mount("/auth", authRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/authentication/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	authRouter := SetAuthRouter()
	apiRouter.Mount("/auth", authRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	auth "github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/auth"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/middleware"
	"github.com/go-chi/chi"
)

func SetAuthRouter() chi.Router {
	var authRouter = chi.NewRouter()
	authRouter.Get("/", server.HealthCheck)
	authRouter.Post("/register", auth.HandleRegisterUser)
	authRouter.Post("/login", auth.HandleLoginUser)
	authRouter.Post("/logout", middleware.Auth(middleware.AuthHandler(auth.HandleUserLogout)))
	return authRouter
}
Location: ./tmp/git_repo/blogx/authentication/pkg/routers/Auth.go
package routers

import (
	auth "github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/auth"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/pkg/middleware"
	"github.com/go-chi/chi"
) func SetAuthRouter() chi.Router {
	var authRouter = chi.NewRouter()
	authRouter.Get("/", server.HealthCheck)
	authRouter.Post("/register", auth.HandleRegisterUser)
	authRouter.Post("/login", auth.HandleLoginUser)
	authRouter.Post("/logout", middleware.Auth(middleware.AuthHandler(auth.HandleUserLogout)))
	return authRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/authentication/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/authentication/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Token     string         `json:"token"`
} func MapLoginUser(dbUser database.User, token string) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Token:     token,
	}
}
Location: ./tmp/git_repo/blogx/authentication/pkg/utils/UserMap.go
package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/authentication/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Token     string         `json:"token"`
}

func MapLoginUser(dbUser database.User, token string) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Token:     token,
	}
}




**************************************************EOF**************************************************package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Blog server
// @description This is the blog server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nBlog server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
}
Location: ./tmp/git_repo/blogx/blog/main.go
package main import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
)

// @title Blog server
// @description This is the blog server for blogx
// @BasePath /v1/api
// @host 127.0.0.1:8000 func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nBlog server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/blog/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/blog/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/blog/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/blog/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
) const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "redis:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}
Location: ./tmp/git_repo/blogx/blog/db/redis/client.go
package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "redis:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}




**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/blog/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package posts

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Create a post
// @version 1
// @description Create a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.CreatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/addBlog [post] func CreatePostHandler(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Title string
		Body  string
		Tags  []string
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.CreatePost(req.Context(), database.CreatePostParams{
		ID:     uuid.New(),
		Title:  bodyDecoded.Title,
		Body:   bodyDecoded.Body,
		UserID: user.ID,
		Tags:   bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	} allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	allBlogsJson, err := json.Marshal(&allBlogs)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	postJson, err := json.Marshal(&post)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	// append post to allBlogs
	allBlogsJson = append(allBlogsJson, postJson...)
	redisClient.Set(req.Context(), "allBlogs", string(allBlogsJson), 180*time.Second)
	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/AddPost.go
package posts

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
) // @title Create a post
// @version 1
// @description Create a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.CreatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/addBlog [post] func CreatePostHandler(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Title string
		Body  string
		Tags  []string
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}

	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.CreatePost(req.Context(), database.CreatePostParams{
		ID:     uuid.New(),
		Title:  bodyDecoded.Title,
		Body:   bodyDecoded.Body,
		UserID: user.ID,
		Tags:   bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	} allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	allBlogsJson, err := json.Marshal(&allBlogs)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	postJson, err := json.Marshal(&post)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}

	// append post to allBlogs
	allBlogsJson = append(allBlogsJson, postJson...)
	redisClient.Set(req.Context(), "allBlogs", string(allBlogsJson), 180*time.Second)
	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}




**************************************************EOF**************************************************package posts

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Delete a post
// @version 1
// @description Delete a post with post id given in the body
// @Tags posts
// @accept json
// @produce json
// @success 204 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/deleteBlog [delete] func DeletePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	dbErr2 := apiConfig.DeletePost(req.Context(), bodyDecoded.PostId)

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}

/*
testPostBody={
	"id": "some post uuid"
}
*/
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/DeletePost.go
package posts

import (
	"encoding/json"
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Delete a post
// @version 1
// @description Delete a post with post id given in the body
// @Tags posts
// @accept json
// @produce json
// @success 204 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/deleteBlog [delete] func DeletePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	dbErr2 := apiConfig.DeletePost(req.Context(), bodyDecoded.PostId)

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}

/*
testPostBody={
	"id": "some post uuid"
}
*/




**************************************************EOF**************************************************package posts

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Like a post
// @version 1
// @description Like a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/like [get] func HandlePostLike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.LikePost(req.Context(), database.LikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.IncreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
} // @title dislike a post
// @version 1
// @description dislike a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/dislike [get] func HandlePostDislike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.DisLikePost(req.Context(), database.DisLikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.DecreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/LikeDislike.go
package posts

import (
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Like a post
// @version 1
// @description Like a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/like [get] func HandlePostLike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.LikePost(req.Context(), database.LikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.IncreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
} // @title dislike a post
// @version 1
// @description dislike a post with post id given as query parameter(post_id)
// @Tags posts
// @accept json
// @produce json
// @param post_id query string true "Post ID"
// @success 200 {object} string
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/dislike [get] func HandlePostDislike(w http.ResponseWriter, req *http.Request, user database.User) {
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	apiConfig := pkg.DbClient
	_, err := apiConfig.DisLikePost(req.Context(), database.DisLikePostParams{
		UserID: user.ID,
		PostID: post_uuid,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.DecreasePostLikes(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, post)
}




**************************************************EOF**************************************************package posts

import (
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Update a post
// @version 1
// @description Update a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.UpdatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/updateBlog [patch] func UpdatePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
		Title  string    `json:"title"`
		Body   string    `json:"body"`
		Tags   []string  `json:"tags"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.UpdatePost(req.Context(), database.UpdatePostParams{
		ID:    bodyDecoded.PostId,
		Title: bodyDecoded.Title,
		Body:  bodyDecoded.Body,
		Tags:  bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/post/UpdatePost.go
package posts

import (
	"encoding/json"
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/google/uuid"
)

// @title Update a post
// @version 1
// @description Update a post with title, body and tags given in the body
// @Tags posts
// @accept json
// @produce json
// @param data body database.UpdatePostParams true "Post details"
// @success 201 {object} utils.PostMap
// @failure 400 {object} string
// @failure 500 {object} string
// @router /blogs/updateBlog [patch] func UpdatePostHandler(w http.ResponseWriter, req *http.Request, _ database.User) {
	type reqBody struct {
		PostId uuid.UUID `json:"post_id"`
		Title  string    `json:"title"`
		Body   string    `json:"body"`
		Tags   []string  `json:"tags"`
	}
	decoder := json.NewDecoder(req.Body)

	bodyDecoded := reqBody{}

	if err := decoder.Decode(&bodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient

	post, dbErr2 := apiConfig.UpdatePost(req.Context(), database.UpdatePostParams{
		ID:    bodyDecoded.PostId,
		Title: bodyDecoded.Title,
		Body:  bodyDecoded.Body,
		Tags:  bodyDecoded.Tags,
	})

	if dbErr2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
		return
	}

	utils.ResponseJson(w, http.StatusOK, utils.MapPost(post))
}




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/blog/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/blog/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetBlogRouter()
	apiRouter.Mount("/blogs", blogRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/blog/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetBlogRouter()
	apiRouter.Mount("/blogs", blogRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	posts "github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/post"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/middleware"
	"github.com/go-chi/chi"
) func SetBlogRouter() chi.Router {
	var blogRouter = chi.NewRouter()
	blogRouter.Get("/", server.HealthCheck)
	blogRouter.Post("/addBlog", middleware.Auth(middleware.AuthHandler(posts.CreatePostHandler)))
	blogRouter.Patch("/updateBlog", middleware.Auth(middleware.AuthHandler(posts.UpdatePostHandler)))
	blogRouter.Delete("/deleteBlog", middleware.Auth(middleware.AuthHandler(posts.DeletePostHandler)))
	blogRouter.Get("/like", middleware.Auth(middleware.AuthHandler(posts.HandlePostLike)))
	blogRouter.Get("/dislike", middleware.Auth(middleware.AuthHandler(posts.HandlePostDislike)))
	return blogRouter
}
Location: ./tmp/git_repo/blogx/blog/pkg/routers/Blog.go
package routers

import (
	posts "github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/post"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/pkg/middleware"
	"github.com/go-chi/chi"
) func SetBlogRouter() chi.Router {
	var blogRouter = chi.NewRouter()
	blogRouter.Get("/", server.HealthCheck)
	blogRouter.Post("/addBlog", middleware.Auth(middleware.AuthHandler(posts.CreatePostHandler)))
	blogRouter.Patch("/updateBlog", middleware.Auth(middleware.AuthHandler(posts.UpdatePostHandler)))
	blogRouter.Delete("/deleteBlog", middleware.Auth(middleware.AuthHandler(posts.DeletePostHandler)))
	blogRouter.Get("/like", middleware.Auth(middleware.AuthHandler(posts.HandlePostLike)))
	blogRouter.Get("/dislike", middleware.Auth(middleware.AuthHandler(posts.HandlePostDislike)))
	return blogRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/blog/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID       uuid.UUID `json:"id"`
	Title    string    `json:"title"`
	Body     string    `json:"body"`
	AuthorID uuid.UUID `json:"author_id"`
	Tags     []string  `json:"tags"`
	Views    int32     `json:"views"`
	Likes    int32     `json:"likes"`
} func MapPost(post database.Post) PostMap {
	return PostMap{
		ID:       post.ID,
		Title:    post.Title,
		Body:     post.Body,
		AuthorID: post.UserID,
		Tags:     post.Tags,
		Views:    post.Views,
		Likes:    post.Likes,
	}
}
Location: ./tmp/git_repo/blogx/blog/pkg/utils/MapPostResponse.go
package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/blog/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID       uuid.UUID `json:"id"`
	Title    string    `json:"title"`
	Body     string    `json:"body"`
	AuthorID uuid.UUID `json:"author_id"`
	Tags     []string  `json:"tags"`
	Views    int32     `json:"views"`
	Likes    int32     `json:"likes"`
} func MapPost(post database.Post) PostMap {
	return PostMap{
		ID:       post.ID,
		Title:    post.Title,
		Body:     post.Body,
		AuthorID: post.UserID,
		Tags:     post.Tags,
		Views:    post.Views,
		Likes:    post.Likes,
	}
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/blog/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************package db

import (
	"fmt"
)

func main() {
	fmt.Println("Database connection")
}
Location: ./tmp/git_repo/blogx/db/main.go
package db

import (
	"fmt"
)

func main() {
	fmt.Println("Database connection")
}




**************************************************EOF**************************************************version: "2"
 sql:
   - schema: "sql/schema"
     queries: "sql/queries"
     engine: "postgresql"
     gen:
       go:
         out: "database"Location: ./tmp/git_repo/blogx/db/sqlc.yaml
 version: "2"
 sql:
   - schema: "sql/schema"
     queries: "sql/queries"
     engine: "postgresql"
     gen:
       go:
         out: "database"



 **************************************************EOF**************************************************
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/feed.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/follower.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nFeed server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
}
Location: ./tmp/git_repo/blogx/feed/main.go
package main import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()
	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nFeed server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/feed/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/feed.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/follower.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/feed/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/feed/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
) const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}
Location: ./tmp/git_repo/blogx/feed/db/redis/client.go
package redis

import (
	"errors"

	"github.com/redis/go-redis/v9"
)

func GetRedisClient() (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})
	if client == nil {
		return nil, errors.New("failed to connect to redis")
	}
	return client, nil
}




**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/feed/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package feed

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
) func AllPostNoPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	if allBlogs != "" {
		//convert string to post
		var posts []database.Post
		json.Unmarshal([]byte(allBlogs), &posts)
		utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
		return
	}
	apiConfig := pkg.DbClient
	allPosts, err := apiConfig.GetAllPosts(req.Context())
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
} func AllPostWithPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	offset_string := req.URL.Query().Get("page_no")
	offset, typeCastError := strconv.Atoi(offset_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	LIMIT := 5
	allPosts, err := apiConfig.GetAllPostsPageWise(req.Context(), database.GetAllPostsPageWiseParams{
		Limit:  int32(LIMIT),
		Offset: int32(offset-1) * 5,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/feed/GetAll.go
package feed

import (
	"encoding/json"
	"net/http"
	"strconv" "github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/redis"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
) func AllPostNoPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	redisClient, err := redis.GetRedisClient()
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	allBlogs, _ := redisClient.Get(req.Context(), "allBlogs").Result()
	if allBlogs != "" {
		//convert string to post
		var posts []database.Post
		json.Unmarshal([]byte(allBlogs), &posts)
		utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
		return
	}
	apiConfig := pkg.DbClient
	allPosts, err := apiConfig.GetAllPosts(req.Context())
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
} func AllPostWithPage(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	offset_string := req.URL.Query().Get("page_no")
	offset, typeCastError := strconv.Atoi(offset_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	LIMIT := 5
	allPosts, err := apiConfig.GetAllPostsPageWise(req.Context(), database.GetAllPostsPageWiseParams{
		Limit:  int32(LIMIT),
		Offset: int32(offset-1) * 5,
	})
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(allPosts))
}




**************************************************EOF**************************************************package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/google/uuid"
)

func GetPostWithPostId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	_, err := apiConfig.GetPostByPostId(req.Context(), post_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.UpdatePostViews(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err2)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapSinglePost(post))
} func GetMyPosts(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
} func GePostsByUserId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	user_id_string := req.URL.Query().Get("user_id")
	user_uuid, typeCastError := uuid.Parse(user_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/feed/GetPostsIdBased.go
package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/google/uuid"
) func GetPostWithPostId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	post_id_string := req.URL.Query().Get("post_id")
	post_uuid, typeCastError := uuid.Parse(post_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	_, err := apiConfig.GetPostByPostId(req.Context(), post_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	post, err2 := apiConfig.UpdatePostViews(req.Context(), post_uuid)
	if err2 != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err2)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapSinglePost(post))
} func GetMyPosts(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}

func GePostsByUserId(w http.ResponseWriter, req *http.Request, _ database.User) {
	apiConfig := pkg.DbClient
	user_id_string := req.URL.Query().Get("user_id")
	user_uuid, typeCastError := uuid.Parse(user_id_string)
	if typeCastError != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, typeCastError)
		return
	}
	posts, err := apiConfig.GetPostsByUserId(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}




**************************************************EOF**************************************************package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
)

func PostsOfUsersIFollow(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsOfFollowers(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
} func PostsILiked(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetAllLikedPosts(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/feed/SpecificPosts.go
package feed

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
)

func PostsOfUsersIFollow(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetPostsOfFollowers(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
} func PostsILiked(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	posts, err := apiConfig.GetAllLikedPosts(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, utils.MapAllPosts(posts))
}




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/feed/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/feed/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetFeedRouter()
	apiRouter.Mount("/feed", blogRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/feed/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	blogRouter := SetFeedRouter()
	apiRouter.Mount("/feed", blogRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/feed"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/middleware"
	"github.com/go-chi/chi"
) func SetFeedRouter() chi.Router {
	var feedRouter = chi.NewRouter()
	feedRouter.Get("/", server.HealthCheck)
	feedRouter.Get("/allPosts", middleware.Auth(middleware.AuthHandler(feed.AllPostNoPage)))
	feedRouter.Get("/allPostsPageWise", middleware.Auth(middleware.AuthHandler(feed.AllPostWithPage)))
	feedRouter.Get("/postWithId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/myPosts", middleware.Auth(middleware.AuthHandler(feed.GetMyPosts)))
	feedRouter.Get("/postWithUserId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/followingUsersPosts", middleware.Auth(middleware.AuthHandler(feed.PostsOfUsersIFollow)))
	feedRouter.Get("/myLikedPosts", middleware.Auth(middleware.AuthHandler(feed.PostsILiked)))

	return feedRouter
}
Location: ./tmp/git_repo/blogx/feed/pkg/routers/Feed.go
package routers import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/feed"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/pkg/middleware"
	"github.com/go-chi/chi"
) func SetFeedRouter() chi.Router {
	var feedRouter = chi.NewRouter()
	feedRouter.Get("/", server.HealthCheck)
	feedRouter.Get("/allPosts", middleware.Auth(middleware.AuthHandler(feed.AllPostNoPage)))
	feedRouter.Get("/allPostsPageWise", middleware.Auth(middleware.AuthHandler(feed.AllPostWithPage)))
	feedRouter.Get("/postWithId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/myPosts", middleware.Auth(middleware.AuthHandler(feed.GetMyPosts)))
	feedRouter.Get("/postWithUserId", middleware.Auth(middleware.AuthHandler(feed.GetPostWithPostId)))
	feedRouter.Get("/followingUsersPosts", middleware.Auth(middleware.AuthHandler(feed.PostsOfUsersIFollow)))
	feedRouter.Get("/myLikedPosts", middleware.Auth(middleware.AuthHandler(feed.PostsILiked)))

	return feedRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/feed/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID        uuid.UUID `json:"id"`
	Title     string    `json:"title"`
	Body      string    `json:"body"`
	AuthorID  uuid.UUID `json:"author_id"`
	Tags      []string  `json:"tags"`
	Views     int32     `json:"views"`
	Likes     int32     `json:"likes"`
	CreatedAt string    `json:"created_at"`
}

func MapSinglePost(post database.Post) PostMap {
	return PostMap{
		ID:        post.ID,
		Title:     post.Title,
		Body:      post.Body,
		AuthorID:  post.UserID,
		Tags:      post.Tags,
		Views:     post.Views,
		Likes:     post.Likes,
		CreatedAt: post.CreatedAt.String(),
	}
} func MapAllPosts(posts []database.Post) []PostMap {
	var postMaps []PostMap
	for _, post := range posts {
		postMaps = append(postMaps, MapSinglePost(post))
	}
	return postMaps
}
Location: ./tmp/git_repo/blogx/feed/pkg/utils/PostMapping.go
package utils

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/feed/db/database"
	"github.com/google/uuid"
)

type PostMap struct {
	ID        uuid.UUID `json:"id"`
	Title     string    `json:"title"`
	Body      string    `json:"body"`
	AuthorID  uuid.UUID `json:"author_id"`
	Tags      []string  `json:"tags"`
	Views     int32     `json:"views"`
	Likes     int32     `json:"likes"`
	CreatedAt string    `json:"created_at"`
}

func MapSinglePost(post database.Post) PostMap {
	return PostMap{
		ID:        post.ID,
		Title:     post.Title,
		Body:      post.Body,
		AuthorID:  post.UserID,
		Tags:      post.Tags,
		Views:     post.Views,
		Likes:     post.Likes,
		CreatedAt: post.CreatedAt.String(),
	}
} func MapAllPosts(posts []database.Post) []PostMap {
	var postMaps []PostMap
	for _, post := range posts {
		postMaps = append(postMaps, MapSinglePost(post))
	}
	return postMaps
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/feed/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig
Location: ./tmp/git_repo/blogx/frontend/next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig




**************************************************EOF**************************************************module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
Location: ./tmp/git_repo/blogx/frontend/postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}




**************************************************EOF**************************************************import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}
export default config
Location: ./tmp/git_repo/blogx/frontend/tailwind.config.ts
import type { Config } from 'tailwindcss' const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}
export default config




**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios";

export const login = async (input: LoginData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const {auth} = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.login
    return await axios.post(endpoint, input)
}

export const register = async (input: RegisterData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { auth } = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.register
    return await axios.post(endpoint, input)
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/auth/handler.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios"; export const login = async (input: LoginData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const {auth} = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.login
    return await axios.post(endpoint, input)
}

export const register = async (input: RegisterData) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { auth } = ROUTES
    const endpoint = serverUrl + auth.url + auth.routes.register
    return await axios.post(endpoint, input)
}



**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { login, register } from "../handler";
import { cookies } from 'next/headers' const request = async (request: NextRequest) => {
    const authType = request.url.split('/').reverse()[0];
    const body = await request.json();
    if (authType == 'login') {
        try {
            const {data, status, statusText} = await login(body)
            const cookieStore = cookies()
            cookieStore.set('auth_token', data.token, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (authType == 'register') {
        try { const { data, status, statusText } = await register(body)
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/auth/[...authType]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { login, register } from "../handler";
import { cookies } from 'next/headers' const request = async (request: NextRequest) => {
    const authType = request.url.split('/').reverse()[0];
    const body = await request.json();
    if (authType == 'login') {
        try {
            const {data, status, statusText} = await login(body)
            const cookieStore = cookies()
            cookieStore.set('auth_token', data.token, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (authType == 'register') {
        try { const { data, status, statusText } = await register(body)
            if (status - 400 < 0) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            }
            return NextResponse.json({
                error: statusText,
                status: status
            })
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}



**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios"

export const addBlog = async (blog: AddBlog, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { blogs } = ROUTES;
    const endpoint = serverUrl + blogs.url + blogs.routes.addBlog;
    // const token = localStorage.getItem('token');
    if (!token || token == "" || token == "null") {
        console.log("out")
        throw new Error("No token");
    }

    return await axios.post(endpoint, blog, {
        headers: {
            'auth_token': token
        }
    })
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/mutate/handlers.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios" export const addBlog = async (blog: AddBlog, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { blogs } = ROUTES;
    const endpoint = serverUrl + blogs.url + blogs.routes.addBlog;
    // const token = localStorage.getItem('token');
    if (!token || token == "" || token == "null") {
        console.log("out")
        throw new Error("No token");
    }

    return await axios.post(endpoint, blog, {
        headers: {
            'auth_token': token
        }
    })
}



**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { addBlog } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const type = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    console.log("token = " + token)
    const body = await request.json();
    if (type == 'addBlog') {
        try {
            const {data, status, statusText} = await addBlog(body, token);
            const cookieStore = cookies()
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({ error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/mutate/[...type]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { addBlog } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const type = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    console.log("token = " + token)
    const body = await request.json();
    if (type == 'addBlog') {
        try {
            const {data, status, statusText} = await addBlog(body, token);
            const cookieStore = cookies()
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({ error: error,
                status: 404
            })
        }
    }
} export {
    request as POST
}



**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios"

export const allBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.allPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    // console.log("endpoint" + endpoint)
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getBlog = async (token: string, id: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    } const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.postWithId + id;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getMyBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.myPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/query/handlers.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios" export const allBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.allPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    // console.log("endpoint" + endpoint)
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getBlog = async (token: string, id: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    } const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.postWithId + id;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}

export const getMyBlogs = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        throw new Error("No server URL");
    }
    const { feed } = ROUTES;
    const endpoint = serverUrl + feed.url + feed.routes.myPosts;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}



**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { allBlogs, getBlog, getMyBlogs } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const possibleTypes = ['allBlogs', 'postWithId', 'myPosts'];
    const currentType = request.url.split('/').reverse();
    const type = possibleTypes.includes(currentType[0]) ? currentType[0] : possibleTypes.includes(currentType[1]) ? currentType[1] : "";
    // console.log(currentType)
    // console.log("url = " + request.url + "type = " + type)
    const token = request.headers.get('Authorization') || '';
    if (type == 'allBlogs') {
        try {
            const {data, status, statusText} = await allBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) { console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'postWithId') {
        try {
            let id = request.url.split('/').reverse()[0];
            const cookieStore = cookies()
            if (id == "undefined" || id == "" || id == undefined) {
                console.log("in")
                id = cookieStore.get('last_post')?.value || "";
            }
            console.log("id=" + id)
            const {data, status, statusText} = await getBlog(token, id);
            console.log(data.id)
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                }) } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'myPosts') {
        try {
            const {data, status, statusText} = await getMyBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404 })
        }
    }
    else {
        return NextResponse.json({
            error: "Invalid request",
            status: 404
        })
    }
} export {
    request as GET
}Location: ./tmp/git_repo/blogx/frontend/src/app/api/blog/query/[...type]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { allBlogs, getBlog, getMyBlogs } from "../handlers";
import { cookies } from "next/headers"; const request = async (request: NextRequest) => {
    const possibleTypes = ['allBlogs', 'postWithId', 'myPosts'];
    const currentType = request.url.split('/').reverse();
    const type = possibleTypes.includes(currentType[0]) ? currentType[0] : possibleTypes.includes(currentType[1]) ? currentType[1] : "";
    // console.log(currentType)
    // console.log("url = " + request.url + "type = " + type)
    const token = request.headers.get('Authorization') || '';
    if (type == 'allBlogs') {
        try {
            const {data, status, statusText} = await allBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) { console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'postWithId') {
        try {
            let id = request.url.split('/').reverse()[0];
            const cookieStore = cookies()
            if (id == "undefined" || id == "" || id == undefined) {
                console.log("in")
                id = cookieStore.get('last_post')?.value || "";
            }
            console.log("id=" + id)
            const {data, status, statusText} = await getBlog(token, id);
            console.log(data.id)
            cookieStore.set('last_post', data.id, {
                expires: new Date(Date.now() + 3000000),
                path: '/',
            })
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                }) } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
    else if (type == 'myPosts') {
        try {
            const {data, status, statusText} = await getMyBlogs(token);
            // console.log(data)
            if (status - 400 < 0) {
                return NextResponse.json({
                    blog: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            console.log(error)
            return NextResponse.json({
                error: error,
                status: 404 })
        }
    }
    else {
        return NextResponse.json({
            error: "Invalid request",
            status: 404
        })
    }
} export {
    request as GET
}



**************************************************EOF**************************************************import { ROUTES } from "@/constants/api.constants";
import axios from "axios";

export const getUserById = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getById;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
} export const getUserByEmail = async (id: string, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getByEmail;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}
Location: ./tmp/git_repo/blogx/frontend/src/app/api/user/[...get]/handler.ts
import { ROUTES } from "@/constants/api.constants";
import axios from "axios"; export const getUserById = async (token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getById;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
} export const getUserByEmail = async (id: string, token: string) => {
    const serverUrl = process.env.GO_SERVER_URL;
    if (!serverUrl) {
        console.log("out")
        throw new Error("No server URL");
    }
    const { user } = ROUTES;
    const endpoint = serverUrl + user.url + user.routes.getByEmail;
    if (!token || token == "" || token == "null") {
        throw new Error("No token");
    }
    return await axios.get(endpoint, {
        headers: {
            'auth_token': token
        }
    })
}




**************************************************EOF**************************************************import { NextRequest, NextResponse } from "next/server";
import { getUserByEmail, getUserById } from "./handler"; const request = async (request: NextRequest) => {
    const reqType = request.url.split('/').reverse()[1];
    const identifier = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    if (reqType === 'user') {
        try {
            const { data, status, statusText } = await getUserById(token);
            if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (reqType == 'email') {
        try {
            const { data, status, statusText } = await getUserByEmail(identifier, token); if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as GET
}
Location: ./tmp/git_repo/blogx/frontend/src/app/api/user/[...get]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getUserByEmail, getUserById } from "./handler"; const request = async (request: NextRequest) => {
    const reqType = request.url.split('/').reverse()[1];
    const identifier = request.url.split('/').reverse()[0];
    const token = request.headers.get('Authorization') || '';
    if (reqType === 'user') {
        try {
            const { data, status, statusText } = await getUserById(token);
            if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    } else if (reqType == 'email') {
        try {
            const { data, status, statusText } = await getUserByEmail(identifier, token); if (status < 400) {
                return NextResponse.json({
                    user: data,
                    status: status
                })
            } else {
                return NextResponse.json({
                    error: statusText,
                    status: status
                })
            }
        } catch (error) {
            return NextResponse.json({
                error: error,
                status: 404
            })
        }
    }
} export {
    request as GET
}




**************************************************EOF**************************************************import { create } from "zustand"; interface PostStore {
    postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string;
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => void;
    postTitle: string;
    setPostTitle: (postTitle: string) => void;
    postDescription: string;
    setPostDescription: (postDescription: string) => void;
    postTags: string[];
    setPostTags: (postTags: string[]) => void;
    postMdx: string;
    setPostMdx: (postMdx: string) => void;
} export const usePostStore = create<PostStore>((set) => ({
    postHtml: "",
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => set({ postHtml }),
    postTitle: "",
    setPostTitle: (postTitle: string) => set({ postTitle }),
    postDescription: "",
    setPostDescription: (postDescription: string) => set({ postDescription }),
    postTags: [],
    setPostTags: (postTags: string[]) => set({ postTags }),
    postMdx: "",
    setPostMdx: (postMdx: string) => set({ postMdx }),
}));Location: ./tmp/git_repo/blogx/frontend/src/app/store/post.store.ts
import { create } from "zustand"; interface PostStore {
    postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string;
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => void;
    postTitle: string;
    setPostTitle: (postTitle: string) => void;
    postDescription: string;
    setPostDescription: (postDescription: string) => void;
    postTags: string[];
    setPostTags: (postTags: string[]) => void;
    postMdx: string;
    setPostMdx: (postMdx: string) => void;
} export const usePostStore = create<PostStore>((set) => ({
    postHtml: "",
    setPostHtml: (postHtml: React.ReactElement<any, string | React.JSXElementConstructor<any>> | string) => set({ postHtml }),
    postTitle: "",
    setPostTitle: (postTitle: string) => set({ postTitle }),
    postDescription: "",
    setPostDescription: (postDescription: string) => set({ postDescription }),
    postTags: [],
    setPostTags: (postTags: string[]) => set({ postTags }),
    postMdx: "",
    setPostMdx: (postMdx: string) => set({ postMdx }),
}));



**************************************************EOF**************************************************const middleLayer = "/v1/api"

export const AUTH_SERVER = middleLayer + '/auth'
export const BLOGS_SERVER = middleLayer + '/blogs'
export const FEED_SERVER = middleLayer + '/feed'
export const USER_SERVER = middleLayer + '/user'

export const AUTH_ROUTES = {
    "login": "/login", 
    "register": "/register", 
    "logout": "/logout", 
}

export const BLOGS_ROUTES = {
    "addBlog": "/addBlog",
    "updateBlog": "/updateBlog",
    "deleteBlog": "/deleteBlog",
    "likeBlog": "/likeBlog?post_id=",
    "dislikeBlog": "/dislikeBlog?post_id=",
}

export const FEED_ROUTES = {
    "allPosts": "/allPosts",
    "allPostsPageWise": "/allPostsPageWise?page_no=",
    "postWithId": "/postWithId?post_id=",
    "postWithUserId": "/postWithUserId?user_id=",
    "myPosts": "/myPosts",
    "followingPosts": "/followingUsersPosts",
    "likedPosts": "/myLikedPosts",
} export const USER_ROUTES = {
    "delete": "/delete",
    "follow": "/follow/toFollowId=",
    "unfollow": "/unfollow/toUnfollowId=",
    "updateBio": "/update/bio",
    "updatePassword": "/update/password",
    "getById": "/get",
    "getByEmail": "/get/email",
}

export const ROUTES = {
    "auth": {
        routes: AUTH_ROUTES,
        url: AUTH_SERVER
    },
    "blogs": {
        routes: BLOGS_ROUTES,
        url: BLOGS_SERVER
    },
    "feed": {
        routes: FEED_ROUTES,
        url: FEED_SERVER
    },
    "user": {
        routes: USER_ROUTES,
        url: USER_SERVER
    }
}Location: ./tmp/git_repo/blogx/frontend/src/constants/api.constants.ts const middleLayer = "/v1/api"

export const AUTH_SERVER = middleLayer + '/auth'
export const BLOGS_SERVER = middleLayer + '/blogs'
export const FEED_SERVER = middleLayer + '/feed'
export const USER_SERVER = middleLayer + '/user'

export const AUTH_ROUTES = {
    "login": "/login", 
    "register": "/register", 
    "logout": "/logout", 
}

export const BLOGS_ROUTES = {
    "addBlog": "/addBlog",
    "updateBlog": "/updateBlog",
    "deleteBlog": "/deleteBlog",
    "likeBlog": "/likeBlog?post_id=",
    "dislikeBlog": "/dislikeBlog?post_id=",
}

export const FEED_ROUTES = {
    "allPosts": "/allPosts",
    "allPostsPageWise": "/allPostsPageWise?page_no=",
    "postWithId": "/postWithId?post_id=",
    "postWithUserId": "/postWithUserId?user_id=",
    "myPosts": "/myPosts",
    "followingPosts": "/followingUsersPosts",
    "likedPosts": "/myLikedPosts",
} export const USER_ROUTES = {
    "delete": "/delete",
    "follow": "/follow/toFollowId=",
    "unfollow": "/unfollow/toUnfollowId=",
    "updateBio": "/update/bio",
    "updatePassword": "/update/password",
    "getById": "/get",
    "getByEmail": "/get/email",
}

export const ROUTES = {
    "auth": {
        routes: AUTH_ROUTES,
        url: AUTH_SERVER
    },
    "blogs": {
        routes: BLOGS_ROUTES,
        url: BLOGS_SERVER
    },
    "feed": {
        routes: FEED_ROUTES,
        url: FEED_SERVER
    },
    "user": {
        routes: USER_ROUTES,
        url: USER_SERVER
    }
}



**************************************************EOF**************************************************const sidebarItems = ['Home', 'Post', 'View', 'Profile', 'Settings', 'Log-out']
const sidebarRoutes = ['/home', '/post', '/view', '/profile', '/settings', '/']

export const SidebarMap :{
    [key: string]: string
} = {
    '/home': 'Home',
    '/post': 'Post',
    '/view': 'View',
    '/profile': 'Profile',
    '/settings': 'Settings',
    '/': 'Log-out'
}

export const SidebarOptions = {
    'items': sidebarItems,
    'routes': sidebarRoutes
}Location: ./tmp/git_repo/blogx/frontend/src/constants/sidebar.constants.ts
const sidebarItems = ['Home', 'Post', 'View', 'Profile', 'Settings', 'Log-out'] const sidebarRoutes = ['/home', '/post', '/view', '/profile', '/settings', '/']

export const SidebarMap :{
    [key: string]: string
} = {
    '/home': 'Home',
    '/post': 'Post',
    '/view': 'View',
    '/profile': 'Profile',
    '/settings': 'Settings',
    '/': 'Log-out'
}

export const SidebarOptions = {
    'items': sidebarItems,
    'routes': sidebarRoutes
}



**************************************************EOF**************************************************declare type LoginData = {
    email: string;
    password: string;
}

declare type RegisterData = {
    username: string;
    email: string;
    password: string;
}Location: ./tmp/git_repo/blogx/frontend/src/types/auth.d.ts
declare type LoginData = {
    email: string;
    password: string;
}

declare type RegisterData = {
    username: string;
    email: string;
    password: string;
}



**************************************************EOF**************************************************declare interface AddBlog {
    "title": string;
    "body": string;
    "tags": !string[];
}

declare interface Blog {
    "id": string;
    "title": string;
    "body": string;
    "tags": !string[];
    "createdAt": !string;
    "views": number;
    "likes": number;
}

declare interface BlogView {
    "id": string;
    "title": string;
    "description": string;
    "body": string;
    "createdAt": !string;
    "views": !number;
    "likes": !number;
    "tags": !string[];
    "image": string;
    "author": string;
}Location: ./tmp/git_repo/blogx/frontend/src/types/blog.d.ts
declare interface AddBlog {
    "title": string;
    "body": string;
    "tags": !string[];
}

declare interface Blog {
    "id": string;
    "title": string;
    "body": string;
    "tags": !string[];
    "createdAt": !string;
    "views": number;
    "likes": number;
} declare interface BlogView {
    "id": string;
    "title": string;
    "description": string;
    "body": string;
    "createdAt": !string;
    "views": !number;
    "likes": !number;
    "tags": !string[];
    "image": string;
    "author": string;
}



**************************************************EOF**************************************************export const handleBold = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "**" + prev.slice(cursorSelectStart, cursorSelectEnd) + "**" + prev.slice(cursorSelectEnd);
    });
};

export const handleItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "*" + prev.slice(cursorSelectStart, cursorSelectEnd) + "*" + prev.slice(cursorSelectEnd);
    });
}

export const handleBoldItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "***" + prev.slice(cursorSelectStart, cursorSelectEnd) + "***" + prev.slice(cursorSelectEnd);
    });
} export const handleUnderline = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "__" + prev.slice(cursorSelectStart, cursorSelectEnd) + "__" + prev.slice(cursorSelectEnd);
    });
}

export const handleHeadings = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, headingLevel: number) => {
    const heading = "#".repeat(headingLevel);
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + heading + " " + prev.slice(cursorSelectStart, cursorSelectEnd) + prev.slice(cursorSelectEnd);
    });
} export const handlerLinks = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, link: string) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "[" + prev.slice(cursorSelectStart, cursorSelectEnd) + "](" + link + ")" + prev.slice(cursorSelectEnd);
    });
}

export const handleCodeBlock = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "```" + prev.slice(cursorSelectStart, cursorSelectEnd) + "```" + prev.slice(cursorSelectEnd);
    });
} export const handleHighlight = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "`" + prev.slice(cursorSelectStart, cursorSelectEnd) + "`" + prev.slice(cursorSelectEnd);
    });
}

export const handleNewLine = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "\n <br />\n" + prev.slice(cursorSelectStart);
    });
}Location: ./tmp/git_repo/blogx/frontend/src/utils/markdown.ts
export const handleBold = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "**" + prev.slice(cursorSelectStart, cursorSelectEnd) + "**" + prev.slice(cursorSelectEnd);
    });
}; export const handleItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "*" + prev.slice(cursorSelectStart, cursorSelectEnd) + "*" + prev.slice(cursorSelectEnd);
    });
}

export const handleBoldItalics = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "***" + prev.slice(cursorSelectStart, cursorSelectEnd) + "***" + prev.slice(cursorSelectEnd);
    });
}

export const handleUnderline = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "__" + prev.slice(cursorSelectStart, cursorSelectEnd) + "__" + prev.slice(cursorSelectEnd);
    });
} export const handleHeadings = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, headingLevel: number) => {
    const heading = "#".repeat(headingLevel);
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + heading + " " + prev.slice(cursorSelectStart, cursorSelectEnd) + prev.slice(cursorSelectEnd);
    });
}

export const handlerLinks = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number, link: string) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "[" + prev.slice(cursorSelectStart, cursorSelectEnd) + "](" + link + ")" + prev.slice(cursorSelectEnd);
    });
} export const handleCodeBlock = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "```" + prev.slice(cursorSelectStart, cursorSelectEnd) + "```" + prev.slice(cursorSelectEnd);
    });
}

export const handleHighlight = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number, cursorSelectEnd: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "`" + prev.slice(cursorSelectStart, cursorSelectEnd) + "`" + prev.slice(cursorSelectEnd);
    });
}

export const handleNewLine = (setString: (arg0: (prev: string) => string) => void, cursorSelectStart: number) => {
    setString((prev: string) => {
        return prev.slice(0, cursorSelectStart) + "\n <br />\n" + prev.slice(cursorSelectStart);
    });
} **************************************************EOF**************************************************defaults
         log     global
        mode    http
        option  httplog
        option  dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
 resolvers docker
         parse-resolv-conf
 frontend http-in
         bind *:80 
 
        use_backend authentication if { path_beg /v1/api/auth }
        use_backend blogs if { path_beg /v1/api/blogs }
        use_backend feed if { path_beg /v1/api/feed }
        use_backend user if { path_beg /v1/api/user }
 backend authentication
         balance roundrobin
        server auth_server auth:8080 
 backend blogs
         balance roundrobin
        server blogs_server blog:8081 
 backend feed
         balance roundrobin
        server feed_server feed:8082
 backend user
         balance roundrobin
        server user_server user:8083
 Location: ./tmp/git_repo/blogx/haproxy/haproxy.cfg
 defaults
         log     global
        mode    http
        option  httplog
        option  dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
 resolvers docker
         parse-resolv-conf
 frontend http-in
         bind *:80 
 
        use_backend authentication if { path_beg /v1/api/auth }
        use_backend blogs if { path_beg /v1/api/blogs }
        use_backend feed if { path_beg /v1/api/feed }
        use_backend user if { path_beg /v1/api/user }
 backend authentication
         balance roundrobin
        server auth_server auth:8080 
 backend blogs
         balance roundrobin
        server blogs_server blog:8081 
 backend feed
         balance roundrobin
        server feed_server feed:8082
 backend user
         balance roundrobin
        server user_server user:8083
 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-auth
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-auth
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8080"
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_auth:0.0
           name: auth
           ports:
             - containerPort: 8080
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-auth-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-auth
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-auth
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8080"
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_auth:0.0
           name: auth
           ports:
             - containerPort: 8080
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-blog
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-blog
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8081"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_blog:0.0
           name: blog
           ports:
             - containerPort: 8081
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-blog-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-blog
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-blog
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8081"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_blog:0.0
           name: blog
           ports:
             - containerPort: 8081
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-feed
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-feed
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8082"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_feed:0.0
           name: feed
           ports:
             - containerPort: 8082
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-feed-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-feed
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-feed
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8082"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_feed:0.0
           name: feed
           ports:
             - containerPort: 8082
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-user
   name: api-user
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-user
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-user
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8083"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_user:0.1
           name: user
           ports:
             - containerPort: 8083
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/api-user-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-user
   name: api-user
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: api-user
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: api-user
     spec:
       containers:
         - env:
             - name: BCRYPT_SALT_VALUE
               value: "12"
             - name: DB_HOST
               value: db
             - name: DB_NAME
               value: blogx_db
             - name: DB_PASSWORD
               value: foobarbaz
             - name: DB_PORT
               value: "5432"
             - name: DB_URL
               value: postgres://postgres:foobarbaz@db:5432/blogx_db?sslmode=disable
             - name: DB_USER
               value: postgres
             - name: JWT_SECRET_KEY
               value: blogx_secret_key
             - name: PORT
               value: "8083"
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: sohamkr/blogx_user:0.1
           name: user
           ports:
             - containerPort: 8083
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 ports:
     - name: "8080"
       port: 8080
       targetPort: 8080
   selector:
     io.kompose.service: api-auth
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_auth-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-auth
   name: api-auth
 spec:
 ports:
     - name: "8080"
       port: 8080
       targetPort: 8080
   selector:
     io.kompose.service: api-auth
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 ports:
     - name: "8081"
       port: 8081
       targetPort: 8081
   selector:
     io.kompose.service: api-blog
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_blog-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-blog
   name: api-blog
 spec:
 ports:
     - name: "8081"
       port: 8081
       targetPort: 8081
   selector:
     io.kompose.service: api-blog
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 ports:
     - name: "8082"
       port: 8082
       targetPort: 8082
   selector:
     io.kompose.service: api-feed
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_feed-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-feed
   name: api-feed
 spec:
 ports:
     - name: "8082"
       port: 8082
       targetPort: 8082
   selector:
     io.kompose.service: api-feed
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-user
   name: api-user
 spec:
 ports:
     - name: "8083"
       port: 8083
       targetPort: 8083
   selector:
     io.kompose.service: api-user
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/api_user-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: api-user
   name: api-user
 spec:
 ports:
     - name: "8083"
       port: 8083
       targetPort: 8083
   selector:
     io.kompose.service: api-user
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: networking.k8s.io/v1
 kind: NetworkPolicy
 metadata:
 creationTimestamp: null
   name: blogx-backend-go-default
 spec:
 ingress:
     - from:
         - podSelector:
             matchLabels:
               io.kompose.network/blogx-backend-go-default: "true"
   podSelector:
     matchLabels:
       io.kompose.network/blogx-backend-go-default: "true"
 Location: ./tmp/git_repo/blogx/k8s/blogx-backend-go-default-networkpolicy.yaml
 apiVersion: networking.k8s.io/v1
 kind: NetworkPolicy
 metadata:
 creationTimestamp: null
   name: blogx-backend-go-default
 spec:
 ingress:
     - from:
         - podSelector:
             matchLabels:
               io.kompose.network/blogx-backend-go-default: "true"
   podSelector:
     matchLabels:
       io.kompose.network/blogx-backend-go-default: "true"




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: haproxy
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: haproxy
     spec:
       containers:
         - image: sohamkr/blogx_haproxy:0.0
           name: haproxy
           ports:
             - containerPort: 80
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/haproxy-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: haproxy
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: haproxy
     spec:
       containers:
         - image: sohamkr/blogx_haproxy:0.0
           name: haproxy
           ports:
             - containerPort: 80
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 ports:
     - name: "8000"
       port: 8000
       targetPort: 80
   selector:
     io.kompose.service: haproxy
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/haproxy-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: haproxy
   name: haproxy
 spec:
 ports:
     - name: "8000"
       port: 8000
       targetPort: 80
   selector:
     io.kompose.service: haproxy
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: PersistentVolumeClaim
 metadata:
 creationTimestamp: null
   labels:
     io.kompose.service: pg-data-blogx
   name: pg-data-blogx
 spec:
 accessModes:
     - ReadWriteOnce
   resources:
     requests:
       storage: 100Mi
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/pg-data-blogx-persistentvolumeclaim.yaml
 apiVersion: v1
 kind: PersistentVolumeClaim
 metadata:
 creationTimestamp: null
   labels:
     io.kompose.service: pg-data-blogx
   name: pg-data-blogx
 spec:
 accessModes:
     - ReadWriteOnce
   resources:
     requests:
       storage: 100Mi
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: PersistentVolumeClaim
 metadata:
 creationTimestamp: null
   labels:
     io.kompose.service: postgres-claim1
   name: postgres-claim1
 spec:
 accessModes:
     - ReadWriteOnce
   resources:
     requests:
       storage: 100Mi
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/postgres-claim1-persistentvolumeclaim.yaml
 apiVersion: v1
 kind: PersistentVolumeClaim
 metadata:
 creationTimestamp: null
   labels:
     io.kompose.service: postgres-claim1
   name: postgres-claim1
 spec:
 accessModes:
     - ReadWriteOnce
   resources:
     requests:
       storage: 100Mi
 status: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: postgres
   name: postgres
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: postgres
   strategy:
     type: Recreate
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: postgres
     spec:
       containers:
         - env:
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: postgres:15.1-alpine
           name: db
           ports:
             - containerPort: 5432
           resources: {}
           volumeMounts:
             - mountPath: /var/lib/postgresql/data
               name: pg-data-blogx
             - mountPath: /docker-entrypoint-initdb.d/init.sql
               name: postgres-claim1
       restartPolicy: Always
       volumes:
         - name: pg-data-blogx
           persistentVolumeClaim:
             claimName: pg-data-blogx
         - name: postgres-claim1
           persistentVolumeClaim:
             claimName: postgres-claim1
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/postgres-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: postgres
   name: postgres
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: postgres
   strategy:
     type: Recreate
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: postgres
     spec:
       containers:
         - env:
             - name: POSTGRES_DB
               value: blogx_db
             - name: POSTGRES_PASSWORD
               value: foobarbaz
           image: postgres:15.1-alpine
           name: db
           ports:
             - containerPort: 5432
           resources: {}
           volumeMounts:
             - mountPath: /var/lib/postgresql/data
               name: pg-data-blogx
             - mountPath: /docker-entrypoint-initdb.d/init.sql
               name: postgres-claim1
       restartPolicy: Always
       volumes:
         - name: pg-data-blogx
           persistentVolumeClaim:
             claimName: pg-data-blogx
         - name: postgres-claim1
           persistentVolumeClaim:
             claimName: postgres-claim1
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: postgres
   name: postgres
 spec:
 ports:
     - name: "5432"
       port: 5432
       targetPort: 5432
   selector:
     io.kompose.service: postgres
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/postgres-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: postgres
   name: postgres
 spec:
 ports:
     - name: "5432"
       port: 5432
       targetPort: 5432
   selector:
     io.kompose.service: postgres
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: redis
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: redis
     spec:
       containers:
         - image: redis:7-alpine
           name: redis
           ports:
             - containerPort: 6379
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/redis-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: redis
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: redis
     spec:
       containers:
         - image: redis:7-alpine
           name: redis
           ports:
             - containerPort: 6379
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 ports:
     - name: "6379"
       port: 6379
       targetPort: 6379
   selector:
     io.kompose.service: redis
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/redis-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: redis
   name: redis
 spec:
 ports:
     - name: "6379"
       port: 6379
       targetPort: 6379
   selector:
     io.kompose.service: redis
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: swagger-ui
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: swagger-ui
     spec:
       containers:
         - image: sohamkr/blogx_swagger:0.0
           name: swagger
           ports:
             - containerPort: 8084
           resources: {}
       restartPolicy: Always
 status: {}
 Location: ./tmp/git_repo/blogx/k8s/swagger-ui-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 replicas: 1
   selector:
     matchLabels:
       io.kompose.service: swagger-ui
   strategy: {}
   template:
     metadata:
       annotations:
         kompose.cmd: kompose convert -f ../docker-compose.yaml
         kompose.version: 1.28.0 (c4137012e)
       creationTimestamp: null
       labels:
         io.kompose.network/blogx-backend-go-default: "true"
         io.kompose.service: swagger-ui
     spec:
       containers:
         - image: sohamkr/blogx_swagger:0.0
           name: swagger
           ports:
             - containerPort: 8084
           resources: {}
       restartPolicy: Always
 status: {}




 **************************************************EOF**************************************************
apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 ports:
     - name: "8084"
       port: 8084
       targetPort: 8084
   selector:
     io.kompose.service: swagger-ui
 status:
 loadBalancer: {}
 Location: ./tmp/git_repo/blogx/k8s/swagger_ui-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
 annotations:
     kompose.cmd: kompose convert -f ../docker-compose.yaml
     kompose.version: 1.28.0 (c4137012e)
   creationTimestamp: null
   labels:
     io.kompose.service: swagger-ui
   name: swagger-ui
 spec:
 ports:
     - name: "8084"
       port: 8084
       targetPort: 8084
   selector:
     io.kompose.service: swagger-ui
 status:
 loadBalancer: {}




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-auth
   template:
     metadata:
       labels:
         app: api-auth
     spec:
       containers:
       - name: api-auth
         image: sohamkr/blogx_auth:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8080"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8080
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8080
     targetPort: 8080
   selector:
     app: api-auth

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-auth-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-auth
   minReplicas: 2
   maxReplicas: 5
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70Location: ./tmp/git_repo/blogx/k8s/updated/api_auth_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-auth
   template:
     metadata:
       labels:
         app: api-auth
     spec:
       containers:
       - name: api-auth
         image: sohamkr/blogx_auth:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8080"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8080
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-auth
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8080
     targetPort: 8080
   selector:
     app: api-auth

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-auth-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-auth
   minReplicas: 2
   maxReplicas: 5
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70



 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-blog
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-blog
   template:
     metadata:
       labels:
         app: api-blog
     spec:
       containers:
       - name: api-blog
         image: sohamkr/blogx_blog:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8081"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8081
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-blog
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8081
     targetPort: 8081
   selector:
     app: api-blog

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-blog-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-blog
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
 Location: ./tmp/git_repo/blogx/k8s/updated/api_blog_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-blog
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-blog
   template:
     metadata:
       labels:
         app: api-blog
     spec:
       containers:
       - name: api-blog
         image: sohamkr/blogx_blog:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8081"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8081
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-blog
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8081
     targetPort: 8081
   selector:
     app: api-blog

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-blog-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-blog
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-feed
   template:
     metadata:
       labels:
         app: api-feed
     spec:
       containers:
       - name: api-feed
         image: sohamkr/blogx_feed:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8082"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8082
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8082
     targetPort: 8082
   selector:
     app: api-feed

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-feed-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-feed
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
 Location: ./tmp/git_repo/blogx/k8s/updated/api_feed_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-feed
   template:
     metadata:
       labels:
         app: api-feed
     spec:
       containers:
       - name: api-feed
         image: sohamkr/blogx_feed:0.0
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8082"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8082
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-feed
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8082
     targetPort: 8082
   selector:
     app: api-feed

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-feed-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-feed
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-user
   template:
     metadata:
       labels:
         app: api-user
     spec:
       containers:
       - name: api-user
         image: sohamkr/blogx_user:0.1
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8083"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8083
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8083
     targetPort: 8083
   selector:
     app: api-user

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-user-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-user
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
 Location: ./tmp/git_repo/blogx/k8s/updated/api_user_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: api-user
   template:
     metadata:
       labels:
         app: api-user
     spec:
       containers:
       - name: api-user
         image: sohamkr/blogx_user:0.1
         env:
         - name: POSTGRES_DB
           value: blogx_db
         - name: POSTGRES_PASSWORD
           value: foobarbaz
         - name: DB_HOST
           value: postgres
         - name: DB_PORT
           value: "5432"
         - name: DB_USER
           value: postgres
         - name: DB_PASSWORD
           value: foobarbaz
         - name: DB_NAME
           value: blogx_db
         - name: PORT
           value: "8083"
         - name: JWT_SECRET_KEY
           value: blogx_secret_key
         - name: BCRYPT_SALT_VALUE
           value: "12"
         - name: DB_URL
           value: "postgres://postgres.roharsahwtuwaclsianl:mT5iappOoDza077K@aws-0-us-west-1.pooler.supabase.com:5432/postgres"
         ports:
         - containerPort: 8083
         resources:
           requests:
             cpu: "250m"

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: api-user
   namespace: blogx-cc
 spec:
 type: LoadBalancer
   ports:
   - port: 8083
     targetPort: 8083
   selector:
     app: api-user

 ---
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
 name: api-user-hpa
   namespace: blogx-cc
 spec:
 scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: api-user
   minReplicas: 2
   maxReplicas: 6
   behavior:
     scaleUp:
       stabilizationWindowSeconds: 0
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Pods
         value: 1
         periodSeconds: 15
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70




 **************************************************EOF**************************************************
apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: haproxy
   template:
     metadata:
       labels:
         app: haproxy
     spec:
       containers:
       - name: haproxy
         image: sohamkr/blogx_haproxy:0.0
         ports:
         - containerPort: 80

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 ports:
   - port: 80
     targetPort: 80
   selector:
     app: haproxy
   type: LoadBalancer
 Location: ./tmp/git_repo/blogx/k8s/updated/haproxy_manifest.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: haproxy
   template:
     metadata:
       labels:
         app: haproxy
     spec:
       containers:
       - name: haproxy
         image: sohamkr/blogx_haproxy:0.0
         ports:
         - containerPort: 80

 ---
 apiVersion: v1
 kind: Service
 metadata:
 name: haproxy
   namespace: blogx-cc
 spec:
 ports:
   - port: 80
     targetPort: 80
   selector:
     app: haproxy
   type: LoadBalancer




 **************************************************EOF**************************************************
Location: ./tmp/git_repo/blogx/k8s/updated/redis_manifest.yaml




 **************************************************EOF**************************************************
package main

import (
	_ "github.com/SohamRatnaparkhi/blogx-backend-go/swagger/docs"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func main() {
	r := gin.Default()
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	r.Run(":8084")
}
Location: ./tmp/git_repo/blogx/swagger/main.go
package main

import (
	_ "github.com/SohamRatnaparkhi/blogx-backend-go/swagger/docs"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func main() {
	r := gin.Default()
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
	r.Run(":8084")
}




**************************************************EOF**************************************************// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag" const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Login a user with email and password given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse" }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Logout a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "202": {
                        "description": "Accepted", "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a user with fist name, last name, email, password and bio given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [ "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "parameters": [
                    {
                        "description": "User details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema"
                        }
                    },
                    "400": { "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/addBlog": {
            "post": {
                "description": "Create a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data", "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/deleteBlog": {
            "delete": {
                "description": "Delete a post with post id given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    }, "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/dislike": {
            "get": {
                "description": "dislike a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": { "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/like": {
            "get": {
                "description": "Like a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ], "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/updateBlog": {
            "patch": {
                "description": "Update a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams"
                        }
                    }
                ], "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isadmin": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema": {
            "type": "object",
            "properties": {
                "bio": {
                    "$ref": "#/definitions/sql.NullString"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": { "type": "string"
                },
                "is_admin": {
                    "type": "boolean"
                },
                "last_name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                } }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "string"
                },
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string" },
                "likes": {
                    "type": "integer"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "sql.NullString": {
            "type": "object",
            "properties": {
                "string": {
                    "type": "string"
                },
                "valid": {
                    "description": "Valid is true if String is not NULL",
                    "type": "boolean"
                }
            }
        }
    }
}` // SwaggerInfo holds exported Swagger Info so clients can modify it var SwaggerInfo = &swag.Spec{
	Version:          "",
	Host:             "127.0.0.1:8000",
	BasePath:         "/v1/api",
	Schemes:          []string{},
	Title:            "Authentication server",
	Description:      "This is the authentication server for blogx",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
} func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
Location: ./tmp/git_repo/blogx/swagger/docs/docs.go
// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag" const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Login a user with email and password given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse" }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Logout a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "responses": {
                    "202": {
                        "description": "Accepted", "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a user with fist name, last name, email, password and bio given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [ "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "parameters": [
                    {
                        "description": "User details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema"
                        }
                    },
                    "400": { "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/addBlog": {
            "post": {
                "description": "Create a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data", "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/deleteBlog": {
            "delete": {
                "description": "Delete a post with post id given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    }, "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/dislike": {
            "get": {
                "description": "dislike a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": { "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/like": {
            "get": {
                "description": "Like a post with post id given as query parameter(post_id)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ], "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "type": "string",
                        "description": "Post ID",
                        "name": "post_id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": { "type": "string"
                        }
                    }
                }
            }
        },
        "/blogs/updateBlog": {
            "patch": {
                "description": "Update a post with title, body and tags given in the body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "posts"
                ],
                "parameters": [
                    {
                        "description": "Post details",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams"
                        }
                    }
                ], "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "firstName": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "isadmin": {
                    "type": "boolean"
                },
                "lastName": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse": {
            "type": "object",
            "properties": {
                "bio": { "$ref": "#/definitions/sql.NullString"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema": {
            "type": "object",
            "properties": {
                "bio": {
                    "$ref": "#/definitions/sql.NullString"
                },
                "created_at": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string"
                },
                "id": { "type": "string"
                },
                "is_admin": {
                    "type": "boolean"
                },
                "last_name": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                } }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap": {
            "type": "object",
            "properties": {
                "author_id": {
                    "type": "string"
                },
                "body": {
                    "type": "string"
                },
                "id": {
                    "type": "string" },
                "likes": {
                    "type": "integer"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "title": {
                    "type": "string"
                },
                "views": {
                    "type": "integer"
                }
            }
        },
        "sql.NullString": {
            "type": "object",
            "properties": {
                "string": {
                    "type": "string"
                },
                "valid": {
                    "description": "Valid is true if String is not NULL",
                    "type": "boolean"
                }
            }
        }
    }
}` // SwaggerInfo holds exported Swagger Info so clients can modify it var SwaggerInfo = &swag.Spec{
	Version:          "",
	Host:             "127.0.0.1:8000",
	BasePath:         "/v1/api",
	Schemes:          []string{},
	Title:            "Authentication server",
	Description:      "This is the authentication server for blogx",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
} func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}




**************************************************EOF**************************************************basePath: /v1/api
 definitions:
 github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       createdAt:
         type: string
       email:
         type: string
       firstName:
         type: string
       id:
         type: string
       isadmin:
         type: boolean
       lastName:
         type: string
       password:
         type: string
       updatedAt:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       last_name:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       created_at:
         type: string
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       is_admin:
         type: boolean
       last_name:
         type: string
       updated_at:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       userID:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap:
     properties:
       author_id:
         type: string
       body:
         type: string
       id:
         type: string
       likes:
         type: integer
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       views:
         type: integer
     type: object
   sql.NullString:
     properties:
       string:
         type: string
       valid:
         description: Valid is true if String is not NULL
         type: boolean
     type: object
 host: 127.0.0.1:8000
 info:
 contact: {}
   description: This is the authentication server for blogx
   title: Authentication server
 paths:
 /auth/login:
     post:
       consumes:
       - application/json
       description: Login a user with email and password given in the body
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/logout:
     post:
       consumes:
       - application/json
       description: Logout a user
       produces:
       - application/json
       responses:
         "202":
           description: Accepted
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/register:
     post:
       consumes:
       - application/json
       description: Register a user with fist name, last name, email, password and
         bio given in the body
       parameters:
       - description: User details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /blogs/addBlog:
     post:
       consumes:
       - application/json
       description: Create a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/deleteBlog:
     delete:
       consumes:
       - application/json
       description: Delete a post with post id given in the body
       produces:
       - application/json
       responses:
         "204":
           description: No Content
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/dislike:
     get:
       consumes:
       - application/json
       description: dislike a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/like:
     get:
       consumes:
       - application/json
       description: Like a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/updateBlog:
     patch:
       consumes:
       - application/json
       description: Update a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
 swagger: "2.0"
 Location: ./tmp/git_repo/blogx/swagger/docs/swagger.yaml
 basePath: /v1/api
 definitions:
 github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       createdAt:
         type: string
       email:
         type: string
       firstName:
         type: string
       id:
         type: string
       isadmin:
         type: boolean
       lastName:
         type: string
       password:
         type: string
       updatedAt:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       last_name:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema:
     properties:
       bio:
         $ref: '#/definitions/sql.NullString'
       created_at:
         type: string
       email:
         type: string
       first_name:
         type: string
       id:
         type: string
       is_admin:
         type: boolean
       last_name:
         type: string
       updated_at:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       userID:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams:
     properties:
       body:
         type: string
       id:
         type: string
       tags:
         items:
           type: string
         type: array
       title:
         type: string
     type: object
   github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap:
     properties:
       author_id:
         type: string
       body:
         type: string
       id:
         type: string
       likes:
         type: integer
       tags:
         items:
           type: string
         type: array
       title:
         type: string
       views:
         type: integer
     type: object
   sql.NullString:
     properties:
       string:
         type: string
       valid:
         description: Valid is true if String is not NULL
         type: boolean
     type: object
 host: 127.0.0.1:8000
 info:
 contact: {}
   description: This is the authentication server for blogx
   title: Authentication server
 paths:
 /auth/login:
     post:
       consumes:
       - application/json
       description: Login a user with email and password given in the body
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/logout:
     post:
       consumes:
       - application/json
       description: Logout a user
       produces:
       - application/json
       responses:
         "202":
           description: Accepted
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DBUserResponse'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /auth/register:
     post:
       consumes:
       - application/json
       description: Register a user with fist name, last name, email, password and
         bio given in the body
       parameters:
       - description: User details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_db_database.User'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_authentication_pkg_utils.DbUserFullSchema'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - authentication
   /blogs/addBlog:
     post:
       consumes:
       - application/json
       description: Create a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.CreatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/deleteBlog:
     delete:
       consumes:
       - application/json
       description: Delete a post with post id given in the body
       produces:
       - application/json
       responses:
         "204":
           description: No Content
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/dislike:
     get:
       consumes:
       - application/json
       description: dislike a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/like:
     get:
       consumes:
       - application/json
       description: Like a post with post id given as query parameter(post_id)
       parameters:
       - description: Post ID
         in: query
         name: post_id
         required: true
         type: string
       produces:
       - application/json
       responses:
         "200":
           description: OK
           schema:
             type: string
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
   /blogs/updateBlog:
     patch:
       consumes:
       - application/json
       description: Update a post with title, body and tags given in the body
       parameters:
       - description: Post details
         in: body
         name: data
         required: true
         schema:
           $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_db_database.UpdatePostParams'
       produces:
       - application/json
       responses:
         "201":
           description: Created
           schema:
             $ref: '#/definitions/github_com_SohamRatnaparkhi_blogx-backend-go_blog_pkg_utils.PostMap'
         "400":
           description: Bad Request
           schema:
             type: string
         "500":
           description: Internal Server Error
           schema:
             type: string
       tags:
       - posts
 swagger: "2.0"




 **************************************************EOF**************************************************
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()

	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nUser server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	} fmt.Printf("Server started at PORT %v", PORT)
}
Location: ./tmp/git_repo/blogx/user/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/routers"
	"github.com/go-chi/chi"
	"github.com/go-chi/cors"
	"github.com/joho/godotenv"
) func main() {
	godotenv.Load(".env")
	PORT := os.Getenv("PORT")
	if PORT == "" {
		log.Println("No PORT found")
	}
	router := chi.NewRouter()

	router.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: false,
		MaxAge:           300, // Maximum value not ignored by any of major browsers
	}))

	v1Router := chi.NewRouter()
	router.Mount("/v1", v1Router)
	v1Router.Get("/health", server.HealthCheck)

	apiRouter := routers.SetAllRouters()

	v1Router.Mount("/api", apiRouter)

	fmt.Printf("\nUser server starting at http://localhost:%v\n", PORT)

	server := &http.Server{
		Handler: router,
		Addr:    ":" + PORT,
	}

	err := server.ListenAndServe()

	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Server started at PORT %v", PORT)
} **************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
} func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
Location: ./tmp/git_repo/blogx/user/db/database/db.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/user/db/database/feed.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: feed.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAllLikedPosts = `-- name: GetAllLikedPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE id IN (
        SELECT post_id
        FROM user_likes
        WHERE
            user_likes.user_id = $1
    )
ORDER BY
    likes,
    created_at DESC
` func (q *Queries) GetAllLikedPosts(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllLikedPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts ORDER BY created_at, likes DESC
` func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPostsPageWise = `-- name: GetAllPostsPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
ORDER BY
    created_at,
    likes DESC
LIMIT $1
OFFSET $2
`

type GetAllPostsPageWiseParams struct {
	Limit  int32
	Offset int32
} func (q *Queries) GetAllPostsPageWise(ctx context.Context, arg GetAllPostsPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getAllPostsPageWise, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostId = `-- name: GetPostByPostId :one

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE id = $1
` func (q *Queries) GetPostByPostId(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByPostId, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsByTags = `-- name: GetPostsByTags :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE tags @> $1 :: varchar []
ORDER BY created_at DESC
` func (q *Queries) GetPostsByTags(ctx context.Context, dollar_1 []string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByTags, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserId = `-- name: GetPostsByUserId :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
` func (q *Queries) GetPostsByUserId(ctx context.Context, userID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUserIdPageWise = `-- name: GetPostsByUserIdPageWise :many

SELECT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserIdPageWiseParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
} func (q *Queries) GetPostsByUserIdPageWise(ctx context.Context, arg GetPostsByUserIdPageWiseParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserIdPageWise, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsOfFollowers = `-- name: GetPostsOfFollowers :many

SELECT DISTINCT id, user_id, title, body, likes, views, tags, created_at, updated_at
FROM posts
WHERE posts.user_id IN (
        SELECT following_id
        FROM user_followers
        WHERE follower_id = $1
    )
ORDER BY created_at DESC
` func (q *Queries) GetPostsOfFollowers(ctx context.Context, followerID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsOfFollowers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Body,
			&i.Likes,
			&i.Views,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostViews = `-- name: UpdatePostViews :one

UPDATE posts SET views = views + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) UpdatePostViews(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostViews, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}
Location: ./tmp/git_repo/blogx/user/db/database/follower.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: follower.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const followUser = `-- name: FollowUser :one

INSERT into
    user_followers (follower_id, following_id)
VALUES ($1, $2) ON CONFLICT (following_id, follower_id)
DO NOTHING
RETURNING follower_id, following_id
`

type FollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
} func (q *Queries) FollowUser(ctx context.Context, arg FollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, followUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}

const unfollowUser = `-- name: UnfollowUser :one

DELETE FROM user_followers
WHERE
    follower_id = $1
    AND following_id = $2
RETURNING follower_id, following_id
`

type UnfollowUserParams struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

func (q *Queries) UnfollowUser(ctx context.Context, arg UnfollowUserParams) (UserFollower, error) {
	row := q.db.QueryRowContext(ctx, unfollowUser, arg.FollowerID, arg.FollowingID)
	var i UserFollower
	err := row.Scan(&i.FollowerID, &i.FollowingID)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
)

type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}
Location: ./tmp/git_repo/blogx/user/db/database/models.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"time"

	"github.com/google/uuid"
) type Post struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Title     string
	Body      string
	Likes     int32
	Views     int32
	Tags      []string
	CreatedAt time.Time
	UpdatedAt time.Time
}

type User struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Email     string
	Bio       sql.NullString
	Password  string
	Isadmin   bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserFollower struct {
	FollowerID  uuid.UUID
	FollowingID uuid.UUID
}

type UserLike struct {
	UserID uuid.UUID
	PostID uuid.UUID
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
Location: ./tmp/git_repo/blogx/user/db/database/post.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :one

INSERT into
    posts (id, user_id, title, body, tags)
VALUES ($1, $2, $3, $4, $5) RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type CreatePostParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
	Title  string
	Body   string
	Tags   []string
} func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decreasePostLikes = `-- name: DecreasePostLikes :one

UPDATE posts SET likes = likes - 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

func (q *Queries) DecreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, decreasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec

DELETE FROM posts WHERE id = $1
` func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const disLikePost = `-- name: DisLikePost :one

DELETE FROM user_likes
WHERE
    post_id = $1
    AND user_id = $2 RETURNING user_id, post_id
`

type DisLikePostParams struct {
	PostID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DisLikePost(ctx context.Context, arg DisLikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, disLikePost, arg.PostID, arg.UserID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const increasePostLikes = `-- name: IncreasePostLikes :one

UPDATE posts SET likes = likes + 1 WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
` func (q *Queries) IncreasePostLikes(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, increasePostLikes, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likePost = `-- name: LikePost :one

INSERT INTO user_likes(user_id, post_id) VALUES($1, $2) RETURNING user_id, post_id
`

type LikePostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
} func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) (UserLike, error) {
	row := q.db.QueryRowContext(ctx, likePost, arg.UserID, arg.PostID)
	var i UserLike
	err := row.Scan(&i.UserID, &i.PostID)
	return i, err
}

const updatePost = `-- name: UpdatePost :one

UPDATE posts
SET
    title = $2,
    body = $3,
    tags = $4
WHERE id = $1 RETURNING id, user_id, title, body, likes, views, tags, created_at, updated_at
`

type UpdatePostParams struct {
	ID    uuid.UUID
	Title string
	Body  string
	Tags  []string
} func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Body,
		pq.Array(arg.Tags),
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Body,
		&i.Likes,
		&i.Views,
		pq.Array(&i.Tags),
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}




**************************************************EOF**************************************************// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE users SET bio = $1 WHERE id = $2
` func (q *Queries) UpdateUserBio(ctx context.Context, bio sql.NullString, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserBio, bio, id)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users SET email = $1 WHERE id = $2
`

func (q *Queries) UpdateUserEmail(ctx context.Context, email string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, email, id)
	return err
}

const updateUserFirstName = `-- name: UpdateUserFirstName :exec
UPDATE users SET first_name = $1 WHERE id = $2
`

func (q *Queries) UpdateUserFirstName(ctx context.Context, firstName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserFirstName, firstName, id)
	return err
}

const updateUserLastName = `-- name: UpdateUserLastName :exec
UPDATE users SET last_name = $1 WHERE id = $2
` func (q *Queries) UpdateUserLastName(ctx context.Context, lastName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserLastName, lastName, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password = $1 WHERE id = $2 && email = $3
` func (q *Queries) UpdateUserPassword(ctx context.Context, password string, id uuid.UUID, email string) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, password, id, email)
	return err
}Location: ./tmp/git_repo/blogx/user/db/database/users.sql.go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one

INSERT INTO
    users (
        id,
        first_name,
        last_name,
        password,
        email,
        bio
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at
`

type CreateUserParams struct {
	ID        uuid.UUID
	FirstName string
	LastName  string
	Password  string
	Email     string
	Bio       sql.NullString
} func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.Email,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec

DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one

SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE email = $1
` func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, first_name, last_name, email, bio, password, isadmin, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Bio,
		&i.Password,
		&i.Isadmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE users SET bio = $1 WHERE id = $2
` func (q *Queries) UpdateUserBio(ctx context.Context, bio sql.NullString, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserBio, bio, id)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users SET email = $1 WHERE id = $2
`

func (q *Queries) UpdateUserEmail(ctx context.Context, email string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, email, id)
	return err
}

const updateUserFirstName = `-- name: UpdateUserFirstName :exec
UPDATE users SET first_name = $1 WHERE id = $2
`

func (q *Queries) UpdateUserFirstName(ctx context.Context, firstName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserFirstName, firstName, id)
	return err
}

const updateUserLastName = `-- name: UpdateUserLastName :exec
UPDATE users SET last_name = $1 WHERE id = $2
` func (q *Queries) UpdateUserLastName(ctx context.Context, lastName string, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserLastName, lastName, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password = $1 WHERE id = $2 && email = $3
`

func (q *Queries) UpdateUserPassword(ctx context.Context, password string, id uuid.UUID, email string) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, password, id, email)
	return err
}



**************************************************EOF**************************************************package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()
Location: ./tmp/git_repo/blogx/user/pkg/connection.go
package pkg

import (
	"database/sql"
	"log"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
) func DbInstance() *database.Queries {
	//database connection
	err := godotenv.Load(".env")

	if err != nil {
		log.Fatal("Error loading .env file")
	}
	db_url := os.Getenv("DB_URL")
	if db_url == "" {
		log.Fatal("DB_URL not found in .env file")
	}

	db, dbErr := sql.Open("postgres", db_url)

	if dbErr != nil {
		return nil
	}
	dbQueries := database.New(db)
	return dbQueries
}

var DbClient *database.Queries = DbInstance()




**************************************************EOF**************************************************package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/server/ServerHealth.go
package server

import (
	"fmt"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func HealthCheck(res http.ResponseWriter, _ *http.Request) {
	databaseObject := pkg.DbClient
	if databaseObject == nil {
		utils.ErrorResponse(res, http.StatusInternalServerError, fmt.Errorf("database error"))
		return
	}
	type resp struct {
		Status string `json:"status"`
	}
	utils.ResponseJson(res, 200, resp{
		Status: "ok",
	})
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func DeleteUser(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user_uuid := user.ID
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})

	err := apiConfig.DeleteUser(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/DeleteUser.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func DeleteUser(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user_uuid := user.ID
	http.SetCookie(w, &http.Cookie{
		Name:  "auth_token",
		Value: "",
		Path:  "/",
	})

	err := apiConfig.DeleteUser(req.Context(), user_uuid)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusNoContent, struct{}{})
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/google/uuid"
)

func FollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toFollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.FollowUser(req.Context(), database.FollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
} func UnFollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toUnfollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.UnfollowUser(req.Context(), database.UnfollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/Folllow.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/google/uuid"
) func FollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toFollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.FollowUser(req.Context(), database.FollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
} func UnFollowUser(w http.ResponseWriter, req *http.Request, user database.User) {
	uuid_param := req.URL.Query().Get("toUnfollowId")
	uuid, paramParseErr := uuid.Parse(uuid_param)
	if paramParseErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, paramParseErr)
		return
	}
	apiConfig := pkg.DbClient
	userFollowTuple, followerUpdateErr := apiConfig.UnfollowUser(req.Context(), database.UnfollowUserParams{
		FollowingID: uuid,
		FollowerID:  user.ID,
	})
	if followerUpdateErr != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, followerUpdateErr)
		return
	}
	utils.ResponseJson(w, http.StatusOK, userFollowTuple)
}




**************************************************EOF**************************************************package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func GetUserByID(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByID(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
} func GetUserByEmail(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByEmail(req.Context(), user.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/GetUser.go
package users

import (
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func GetUserByID(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByID(req.Context(), user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
} func GetUserByEmail(w http.ResponseWriter, req *http.Request, user database.User) {
	apiConfig := pkg.DbClient
	user, err := apiConfig.GetUserByEmail(req.Context(), user.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string        `json:"success"`
		User    database.User `json:"user"`
	}{
		Success: "User fetched successfully",
		User:    user,
	})
}




**************************************************EOF**************************************************package users

import (
	"database/sql"
	"encoding/json"
	"net/http"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
)

func UpdateUserBio(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Bio sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserBio(req.Context(), reqBodyDecoded.Bio, user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Bio updated successfully",
	})
} func UpdateUserPassword(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Password string `json:"password"`
		Email    string `json:"email"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserPassword(req.Context(), reqBodyDecoded.Password, user.ID, reqBodyDecoded.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Password updated successfully",
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/handlers/user/Update.go
package users

import (
	"database/sql"
	"encoding/json"
	"net/http" "github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
) func UpdateUserBio(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Bio sql.NullString `json:"bio"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserBio(req.Context(), reqBodyDecoded.Bio, user.ID)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Bio updated successfully",
	})
} func UpdateUserPassword(w http.ResponseWriter, req *http.Request, user database.User) {
	type reqBody struct {
		Password string `json:"password"`
		Email    string `json:"email"`
	}
	decoder := json.NewDecoder(req.Body)
	reqBodyDecoded := reqBody{}
	if err := decoder.Decode(&reqBodyDecoded); err != nil {
		utils.ResponseJson(w, 400, struct {
			Error string `json:"error"`
		}{
			Error: err.Error(),
		})
		return
	}
	apiConfig := pkg.DbClient
	err := apiConfig.UpdateUserPassword(req.Context(), reqBodyDecoded.Password, user.ID, reqBodyDecoded.Email)
	if err != nil {
		utils.ErrorResponse(w, http.StatusInternalServerError, err)
		return
	}
	utils.ResponseJson(w, http.StatusOK, struct {
		Success string `json:"success"`
	}{
		Success: "Password updated successfully",
	})
}




**************************************************EOF**************************************************package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}
Location: ./tmp/git_repo/blogx/user/pkg/middleware/auth.go
package middleware

import (
	"fmt"
	"net/http"
	"os"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/utils"
	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type AuthHandler func(http.ResponseWriter, *http.Request, database.User) func Auth(handler AuthHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		godotenv.Load()
		var jwtKey string = os.Getenv("JWT_SECRET_KEY")
		jwtToken := req.Header.Get("auth_token")
		if jwtToken == "" {
			utils.ErrorResponse(w, http.StatusUnauthorized, fmt.Errorf("no auth token"))
			fmt.Println("No auth token")
			return
		}
		tknStr := jwtToken
		claims := &utils.Claims{}

		tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		})
		if err != nil {
			if err == jwt.ErrSignatureInvalid {
				w.WriteHeader(http.StatusUnauthorized)
				return
			}

			fmt.Println("No valid jwt - " + tknStr)
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		if !tkn.Valid {
			utils.ErrorResponse(w, http.StatusUnauthorized, err)
			return
		}
		userEmail := claims.Creds.Email
		apiConfig := pkg.DbClient user, dbErr2 := apiConfig.GetUserByEmail(req.Context(), userEmail)
		if dbErr2 != nil {
			utils.ErrorResponse(w, http.StatusInternalServerError, dbErr2)
			return
		}

		handler(w, req, user)
	}
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	userRouter := SetUserRouter()
	apiRouter.Mount("/user", userRouter)

	return apiRouter
}
Location: ./tmp/git_repo/blogx/user/pkg/routers/api.go
package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"

	"github.com/go-chi/chi"
)

func SetAllRouters() chi.Router {
	apiRouter := chi.NewRouter()

	apiRouter.Get("/", server.HealthCheck)

	userRouter := SetUserRouter()
	apiRouter.Mount("/user", userRouter)

	return apiRouter
}




**************************************************EOF**************************************************package routers

import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	users "github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/user"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/middleware"
	"github.com/go-chi/chi"
) func SetUserRouter() chi.Router {
	var userRouter = chi.NewRouter()
	userRouter.Get("/", server.HealthCheck)
	userRouter.Delete("/delete", middleware.Auth(middleware.AuthHandler(users.DeleteUser)))
	userRouter.Post("/follow", middleware.Auth(middleware.AuthHandler(users.FollowUser)))
	userRouter.Post("/unfollow", middleware.Auth(middleware.AuthHandler(users.UnFollowUser)))
	userRouter.Post("/update/bio", middleware.Auth(middleware.AuthHandler(users.UpdateUserBio)))
	userRouter.Post("/update/password", middleware.Auth(middleware.AuthHandler(users.UpdateUserPassword)))
	userRouter.Get("/get", middleware.Auth(middleware.AuthHandler(users.GetUserByID)))
	userRouter.Get("/get/email", middleware.Auth(middleware.AuthHandler(users.GetUserByEmail)))
	return userRouter
}
Location: ./tmp/git_repo/blogx/user/pkg/routers/User.go
package routers import (
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/server"
	users "github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/handlers/user"
	"github.com/SohamRatnaparkhi/blogx-backend-go/user/pkg/middleware"
	"github.com/go-chi/chi"
) func SetUserRouter() chi.Router {
	var userRouter = chi.NewRouter()
	userRouter.Get("/", server.HealthCheck)
	userRouter.Delete("/delete", middleware.Auth(middleware.AuthHandler(users.DeleteUser)))
	userRouter.Post("/follow", middleware.Auth(middleware.AuthHandler(users.FollowUser)))
	userRouter.Post("/unfollow", middleware.Auth(middleware.AuthHandler(users.UnFollowUser)))
	userRouter.Post("/update/bio", middleware.Auth(middleware.AuthHandler(users.UpdateUserBio)))
	userRouter.Post("/update/password", middleware.Auth(middleware.AuthHandler(users.UpdateUserPassword)))
	userRouter.Get("/get", middleware.Auth(middleware.AuthHandler(users.GetUserByID)))
	userRouter.Get("/get/email", middleware.Auth(middleware.AuthHandler(users.GetUserByEmail)))
	return userRouter
}




**************************************************EOF**************************************************package utils

import (
	"net/http"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
)

type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
}

func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/utils/JwtToken.go
package utils

import (
	"net/http"
	"os"
	"time" "github.com/golang-jwt/jwt/v5"
	"github.com/joho/godotenv"
) type Credentials struct {
	Email string
	Name  string
}

type Claims struct {
	Creds Credentials
	jwt.RegisteredClaims
} func GetJwt(signerClaims Credentials) (tokenString string, expireTime time.Time, err error) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	expiryTime := time.Now().Add(50 * time.Minute) // restore required after 50 minutes
	claims := Claims{
		Creds: signerClaims,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expiryTime),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err = token.SignedString([]byte(jwtKey))

	return tokenString, expireTime, err
} func RefreshJwt(w http.ResponseWriter, r *http.Request) {
	godotenv.Load()
	var jwtKey string = os.Getenv("JWT_SECRET_KEY")
	c, err := r.Cookie("auth_token")
	if err != nil {
		if err == http.ErrNoCookie {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	tknStr := c.Value
	claims := &Claims{}
	tkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil {
		if err == jwt.ErrSignatureInvalid {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if !tkn.Valid {
		w.WriteHeader(http.StatusUnauthorized)
		return
	} /* 	We ensure that a new token is not issued until enough time has elapsed
	In this case, a new token will only be issued if the old token is within
	30 seconds of expiry. Otherwise, return a bad request status
	*/
	if time.Until(claims.ExpiresAt.Time) > 30*time.Second {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Now, create a new token for the current use, with a renewed expiration time
	expirationTime := time.Now().Add(5 * time.Minute)
	claims.ExpiresAt = jwt.NewNumericDate(expirationTime)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Set the new token as the users `token` cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "auth_token",
		Value:   tokenString,
		Expires: expirationTime,
		Path:    "/",
	})
}




**************************************************EOF**************************************************package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
}

func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}
Location: ./tmp/git_repo/blogx/user/pkg/utils/ServerResponse.go
package utils

import (
	"encoding/json"
	"net/http"
)

func ResponseJson(w http.ResponseWriter, code int, payload interface{}) {
	data, err := json.Marshal(payload)
	if err != nil {
		w.WriteHeader(500)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(data)
} func ErrorResponse(w http.ResponseWriter, code int, err error) {
	ResponseJson(w, code, struct {
		Error string `json:"error"`
	}{
		Error: err.Error(),
	})
}




**************************************************EOF**************************************************package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
} func MapLoginUser(dbUser database.User) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
	}
}
Location: ./tmp/git_repo/blogx/user/pkg/utils/UserMap.go
package utils

import (
	"database/sql"
	"time"

	"github.com/SohamRatnaparkhi/blogx-backend-go/user/db/database"
	"github.com/google/uuid"
)

type DbUserFullSchema struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
	Isadmin   bool           `json:"is_admin"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
} func MapRegisteredUser(dbUser database.User) DbUserFullSchema {
	return DbUserFullSchema{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
		Isadmin:   dbUser.Isadmin,
		CreatedAt: dbUser.CreatedAt,
		UpdatedAt: dbUser.UpdatedAt,
	}
}

type DBUserResponse struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Email     string         `json:"email"`
	Bio       sql.NullString `json:"bio"`
}

func MapLoginUser(dbUser database.User) DBUserResponse {
	return DBUserResponse{
		ID:        dbUser.ID,
		FirstName: dbUser.FirstName,
		LastName:  dbUser.LastName,
		Email:     dbUser.Email,
		Bio:       dbUser.Bio,
	}
}




**************************************************EOF**************************************************